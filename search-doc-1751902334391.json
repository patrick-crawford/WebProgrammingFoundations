{"searchDocs":[{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/example-code","content":"Example Code You may download the sample code for this topic here: Advanced-Routing-Middleware","keywords":"","version":"Next"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/CSS3-Introduction/example-code","content":"Example Code You may download the sample code for this topic here: CSS3-Introduction","keywords":"","version":"Next"},{"title":"Box Model","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/CSS3-Introduction/box-model","content":"","keywords":"","version":"Next"},{"title":"CSS \"Box\" Properties​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingFoundations/CSS3-Introduction/box-model#css-box-properties","content":" The sizes (and style) of each of these can be controlled through CSS properties:  margin / (margin-top, margin-right, margin-bottom and margin-left) border border-style / (border-top-style, border-right-style, border-bottom-style and border-left-style) border-width / border-top-width, border-right-width, border-bottom-width and border-left-width border-color / border-top-color, border-right-color, border-bottom-color and border-left-color padding / padding-top, padding-right, padding-bottom and padding-left  Each of these is a shorthand property that lets you specify multiple CSS properties at the same time. For example, the following are equivalent:  /* Use separate properties for all aspects */ .example1 { border-width: 1px; border-style: solid; border-color: #000; margin-top: 5px; margin-right: 10px; margin-bottom: 15px; margin-left: 20px; } /* Use shorthand properties to do everything at once */ .example2 { border: 1px solid #000; margin: 5px 10px 15px 20px; }   In the code above for margin, notice how the the different portions of themargin get translated into a single line. The order we use follows the same order as a clockface, the numbers begin at the top and go clockwise around:  .example2 { /* top right bottom left */ margin: 5px 10px 15px 20px; }   We often shorten our lists when multiple properties share the same values:  .example3 { /* Everything is different, specify them all */ margin: 10px 5px 15px 20px; } .example4 { /* Top and bottom are both 10px, right and left are both 5px */ margin: 10px 5px; } .example5 { /* Top, bottom, left, and right are all 5px */ margin: 5px; }   When two elements that specify a margin at the top and bottom are stacked, the browser will collapse (i.e., combine) the two into a single margin, whose size is the largest of the two. Consider the following CSS:  &lt;style&gt; h1 { margin-bottom: 25px; } p { margin-top: 20px; } &lt;/style&gt; &lt;h1&gt;Heading&lt;/h1&gt; &lt;p&gt;Paragraph&lt;/p&gt;   Here the stylesheet calls for a &lt;p&gt; element to have 20px of whitespace above it. However, since the &lt;h1&gt; has 25px of whitespace below it, when the two are placed one after the other, the distance between them will be 25px vs. 45px(i.e., the browser won't apply both margins, but just make sure that both margins are honoured).  ","version":"Next","tagName":"h2"},{"title":"\"Displaying\" an Element​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingFoundations/CSS3-Introduction/box-model#displaying-an-element","content":" CSS lets us control how an element gets displayed. This is a large topic, and we'll give an overview of some of the most common display types. Further study is required to fully appreciate the subtleties of each layout method.  Perhaps the easiest way to get started understanding display types is to look at what display: none; does:  &lt;style&gt; .hidden { display: none; } .error-msg { /* styles for error message UI */ } &lt;/style&gt; &lt;div class=&quot;hidden error-msg&quot;&gt; &lt;h1&gt;Error!&lt;/h1&gt; &lt;p&gt;There was an error completing your request.&lt;/p&gt; &lt;/div&gt;   When an element uses a display type of none, nothing will be painted to the screen. This includes the element itself, but also any of its children.  If elements don't have a display type of none, they get included in the render tree and eventually painted to the screen. If we don't specify a display type, the default is inline for inline elements (like &lt;a&gt; and &lt;span&gt;) and block for block-level elements (like &lt;p&gt; and &lt;div&gt;).  With inline, boxes are laid out horizontally (typically left to right, unless we are doing rtl), starting at the top corner of the parent.  We can also specify that an element should be display: block;, which will layout blocks in a vertical way, using margin to determine the space between them. To understand the difference, try this using this snippet of code an HTML page, and change the display from block to inline:  &lt;style&gt; h1 { display: block; /* try changing to `inline` */ } &lt;/style&gt; &lt;h1&gt;One&lt;/h1&gt; &lt;h1&gt;Two&lt;/h1&gt; &lt;h1&gt;Three3&lt;/h1&gt;   We can also control the way that elements are laid out within an element (i.e., its children). Some of the display types for inside layout options include:  table - make elements behave as though they were part of a &lt;table&gt;flex - lays out the contents according to the flexbox modelgrid - lays out the contents according to the grid model  A great way to learn a bit about the latter two is to work through the following online CSS learning games:  Flexbox FroggyFlexbox DefenseGrid Garden  ","version":"Next","tagName":"h2"},{"title":"\"Positioning\" an Element​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingFoundations/CSS3-Introduction/box-model#positioning-an-element","content":" Many web interface designs require more sophisticated element positioning than simply allowing everything to flow. Sometimes we need very precise control over where things end up, and how the page reacts to scrolling or movement.  To accomplish this kind of positioning we can use the CSS position propertyto override the defaults provided by the browser.  static - the default, where elements are positioned according to the normal flow of the document relative - elements are positioned according to the normal flow, but with extra offsets (top, bottom, left, right), allowing content to overlap absolute - elements are positioned separate from normal flow, in their own &quot;layer&quot; relative to their ancestor element, and don't affect other elements. Useful for things like popups, dialog boxes, etc. fixed - elements are positioned separate from normal flow, and get positioned relative to the viewport. sticky - a hybrid of relative and fixed, allowing an element to be positioned relatively, but then &quot;stick&quot; when scrolling or resizing the viewport. This is often used for headings, which can be scrolled up, but then stay in place as you continue down into the document.  ","version":"Next","tagName":"h2"},{"title":"z-index Property​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingFoundations/CSS3-Introduction/box-model#z-index-property","content":" In addition to controlling how elements are positioned in the X and Y planes, we can also stack elements on top of each other in different layers. We achieve this through the use of the z-index property.  The z-index is a value positive or negative integer, indicting which stack level the element should be placed within. The default stack level is 0, so using a z-index higher than 0 will place the content on top of anything below it.  The z-index is often used with position to place content in arbitrary positions overtop of other content. For example, a modal window that appears as a dialog box, over the site's content.  ","version":"Next","tagName":"h3"},{"title":"overflow Property​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingFoundations/CSS3-Introduction/box-model#overflow-property","content":" When the contents on an element are too large to be displayed, we have options as to how the browser will display the overflowing content. To do this, we work with the overflow, overflow-x, overflow-y properties  visible - default. No scroll bars provided, content is not clipped.scroll - always include scroll bars, content is clipped and and scroll if requiredauto - only include scroll bars when necessary, content is clipped and and scroll if requiredhidden - content is clipped, no scroll bars provided.  ","version":"Next","tagName":"h3"},{"title":"Validating CSS​","type":1,"pageTitle":"Box Model","url":"/WebProgrammingFoundations/CSS3-Introduction/box-model#validating-css","content":" If you recall from last week, we introduced an online validator to check your HTML code for errors. There are similar tools for CSS, for example:  https://jigsaw.w3.org/css-validator/  The above allows you to enter a URL to an existing web page, or enter CSS directly in a text field. It will then attempt to parse your CSS and report back on any errors or warnings. ","version":"Next","tagName":"h2"},{"title":"Application, Request & Response Objects","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects","content":"","keywords":"","version":"Next"},{"title":"The Application object​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#the-application-object","content":" The &quot;app&quot; object in the example above represents the express main application object. It contains several methods for tasks, such as processing route requests, setting up middleware, and managing html views or view engines.  In the above example, we set a route on the host to handle HTTP GET requests to “/”. This means any &quot;GET&quot; requests to localhost:8080/ will be sent to this function. A typical route handler in express (like the one above) is created by invoking a function on the app object using the HTTP method (verb) that matches the type of request and passing it two parameters: a string representing the route, and a callback function to invoke when the route is matched. In this case, we wish to handle GET requests for the default route &quot;/&quot; (typically requests from the browser to load the page initially).  Here are some of the commonly used application properties and methods that we will use throughout these notes.  ","version":"Next","tagName":"h2"},{"title":"app.all()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#appall","content":" This method is used to register a single callback for a route that matches any HTTP Method IE: GET, PUT, POST, DELETE, etc.  app.all('/http-testing', (req, res) =&gt; { res.send('test complete'); });   ","version":"Next","tagName":"h3"},{"title":"HTTP Verb Methods​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#http-verb-methods","content":" We can also respond to a request a callback for a route using a single HTTP Method (ie: app.get() from our Simple Web Server using Express.js example):  app.get('/get-test', (req, res) =&gt; { res.send('GET Test Complete'); }); app.put('/put-test', (req, res) =&gt; { res.send('PUT Test Complete'); }); app.post('/post-test', (req, res) =&gt; { res.send('POST Test Complete'); }); app.delete('/delete-test', (req, res) =&gt; { res.send('DELETE Test Complete'); }); // etc.   ","version":"Next","tagName":"h3"},{"title":"app.locals​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#applocals","content":" The &quot;locals&quot; property allows you to attach local variables to the application, which persist throughout the life of the app. You can access local variables in templates rendered within the application (discussed in &quot;Template Engines&quot;).  app.locals.title = 'My App';   ","version":"Next","tagName":"h3"},{"title":"app.listen()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#applisten","content":" As we have seen, this function is used to start the HTTP server listening for connections on a specific port, ie:  const HTTP_PORT = process.env.PORT || 8080; // (route handlers / middleware) ... app.listen(HTTP_PORT, () =&gt; { console.log('server listening on: ' + HTTP_PORT); });   ","version":"Next","tagName":"h3"},{"title":"app.set()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#appset","content":" The &quot;set&quot; method assigns a value to a specific &quot;setting&quot;. According to the documentation, you may store any value that you want in your own custom &quot;setting&quot;, however certain settings can be used to configure the behavior of the server. For example, we will be setting the value of the &quot;view engine&quot; setting when configuring our template engine.  ","version":"Next","tagName":"h3"},{"title":"app.use()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#appuse","content":" The use method is used to add middleware to your application. Middleware consists of functions (typically placed before the route handlers) that automatically execute either when a specified path is matched or globally before every request. This is very useful when you want to do something with every request like add properties to the request object or check if a user is logged in.  This is discussed further in the next section: &quot;Middleware&quot;  ","version":"Next","tagName":"h3"},{"title":"The Request object​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#the-request-object","content":" The &quot;req&quot; object represents the object that contains all the information and metadata for the request sent to the server. When you see examples of the request object in use, it will typically be referred to as ‘req’ (short for request object).  Some of the commonly used request properties and methods used throughout these notes are:  ","version":"Next","tagName":"h2"},{"title":"req.body​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#reqbody","content":" The req.body property contains the data submitted as part of request. It requires that you use a &quot;body parsing&quot; middleware (discussed in: &quot;Middleware&quot;) which will attach data (properties) to req.body. If you post data in your request, this is how you access that data.  app.post('/urlencoded-test', (req, res) =&gt; { res.send(req.body); });   ","version":"Next","tagName":"h3"},{"title":"req.cookies​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#reqcookies","content":" If we wish to read the value specific &quot;cookie&quot; value, ie:  &quot;a small piece of data that a server sends to a user's web browser. The browser may store the cookie and send it back to the same server with later requests.&quot; https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies  we can reference it using the corresponding property on the &quot;req.cookies&quot; object:  // Cookie: name=tj console.log(req.cookies.name); // &quot;tj&quot;   However, like &quot;req.body&quot; above, we must use a (&quot;cookie parsing&quot;) middleware function to populate &quot;req.cookies&quot; with data from the cookie  ","version":"Next","tagName":"h3"},{"title":"req.params​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#reqparams","content":" The &quot;params&quot; property is used when we wish to read the values of &quot;Route Parameters&quot; defined in our route handlers:  &quot;Route parameters are named URL segments used to capture values at specific positions in the URL. The named segments are prefixed with a colon and then the name (E.g., /:your_parameter_name/).&quot; https://developer.mozilla.org/en-US/docs/Learn/Server-side/Express_Nodejs/routes#route_parameters  For example, if we wish to match all GET requests for the route &quot;/employee/employeeNum&quot;, where employeeNum can be any value, ie: &quot;123&quot;, &quot;abc456&quot;, etc, we can use the following code:  app.get('/employee/:employeeNum', (req, res) =&gt; { res.send(`Employee Number: ${req.params.employeeNum}`); });   ","version":"Next","tagName":"h3"},{"title":"req.query​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#reqquery","content":" The &quot;query&quot; property is needed when we wish to read the values of the &quot;query string&quot; in the url:  A query string is a part of a uniform resource locator (URL) that assigns values to specified parameters. A query string commonly includes fields added to a base URL by a Web browser or other client application, for example as part of an HTML document, choosing the appearance of a page, or jumping to positions in multimedia content A typical URL containing a query string is as follows: https://example.com/over/there?name=ferret https://en.wikipedia.org/wiki/Query_string  For example, if we wanted to match a GET request for the route &quot;/products&quot; that also supports the optional query string value &quot;onSale&quot;, ie: &quot;/products?onSale=true&quot;, we could use the code:  app.get('/products', (req, res) =&gt; { let result = 'all Products'; // NOTE: query parameter values are always strings if (req.query.onSale == 'true') { result += ' (on sale)'; } res.send(result); });   When designing route handlers that can accept query string values, we do not include them in the &quot;route&quot; (ie: &quot;/products&quot;). Additionally, since the route will match without the &quot;onSale&quot; query sting value, it is important to return a value if it's missing (ie: &quot;all Products&quot; or an error if the query parameter must be present)  NOTE: Multiple query parameters may also be used, and are separated by an ampersand, &quot;&amp;&quot;: https://example.com/path/to/page?name=ferret&amp;color=purple  ","version":"Next","tagName":"h3"},{"title":"req.get()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#reqget","content":" req.get() is necessary for checking the values of specific HTTP headers sent with the request. For example:  app.get('/hello', (req, res) =&gt; { res.send(`Hello ${req.get('user-agent')}`); });   Here, when a user requests the &quot;/hello&quot; route, they should see the text &quot;Hello&quot; followed by the content of the &quot;user-agent&quot; header sent with the request.  ","version":"Next","tagName":"h3"},{"title":"The Response object​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#the-response-object","content":" The &quot;res&quot; object represents the object that contains all the information and metadata for a response sent from the server. When you see examples of the response object in use it will typically be referred to as ‘res’ (short for response object). The data you send back from the server can be one of several different formats - the most common of which are HTML, JSON, CSS, JS and plain files (.pdf, .txt, .jpg, .png, etc).  Some of the commonly used response properties and methods used throughout these notes are:  ","version":"Next","tagName":"h2"},{"title":"res.cookie()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#rescookie","content":" This allows you to send a cookie with the response, specified using a name = value key pair. You can set the value to a string / object using JSON notation and it will be included in the &quot;Set-Cookie&quot; header of the response. For example:  app.get('/cookie-test', (req, res) =&gt; { res.cookie('message', 'Hello World!'); res.send('Cookie Sent!'); });   ","version":"Next","tagName":"h3"},{"title":"res.set()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#resset","content":" res.set() enables you to set the values of specific / custom HTTP headers sent with the request. For example:  app.get('/custom', (req, res) =&gt; { res.set('Custom-Header', 'MyValue'); res.send(`Custom-Header Sent`); });   ","version":"Next","tagName":"h3"},{"title":"res.end()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#resend","content":" res.end() is used you want to end a response immediately and send nothing back. For example, we may wish to send a &quot;204 - No Content&quot; status code, which indicates that &quot;a request has succeeded, but that the client doesn't need to navigate away from its current page&quot;. For example:  app.put('/update', (req, res) =&gt; { // ... (update logic) res.status(204).end(); });   ","version":"Next","tagName":"h3"},{"title":"res.redirect()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#resredirect","content":" The res.redirect() method is used to perform a redirect to another page on your site, go back to the previous page, or redirect to another domain. For example:  app.get('/to-google', (req, res) =&gt; { res.redirect('https://www.google.ca/'); });   ","version":"Next","tagName":"h3"},{"title":"res.send()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#ressend","content":" This is the primary response method to send a response to the client. You can send a String, Object, Array, or even a Buffer object back to the client. The send() method will automatically set the Content-Type header for you based on the type of data sent. For example:  app.get('/json-test', (req, res) =&gt; { res.send({ message: 'Hello World!' }); // Content-Type: application/json; charset=utf-8 }); app.get('/plain-text-test', (req, res) =&gt; { res.send('Hello World!'); // Content-Type: text/html; charset=utf-8 });   NOTE: When sending a JavaScript object back (as in the example above), the &quot;send()&quot; method will internally convert it to a JSON-formatted string  ","version":"Next","tagName":"h3"},{"title":"res.sendFile()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#ressendfile","content":" As we have seen, this function is used when we wish to send a file (typically .html) back to the client. We use path.join() to safely join __dirname with the path of the file to be sent. This function also correctly sets the Content-Type response HTTP header based on the file extension. For example:  app.get('/', (req, res) =&gt; { res.sendFile(path.join(__dirname, '/views/home.html')); });   ","version":"Next","tagName":"h3"},{"title":"res.status()​","type":1,"pageTitle":"Application, Request & Response Objects","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/application-request-response-objects#resstatus","content":" res.status() is used to set a specific status code for the response (as seen above in the res.end() example). This will be useful when handling client / server errors and setting 4xx / 5xx series error codes. More detail is discussed in the following &quot;Middleware&quot; section. ","version":"Next","tagName":"h3"},{"title":"Syntax / Selectors","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors","content":"","keywords":"","version":"Next"},{"title":"CSS Syntax​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#css-syntax","content":" CSS syntax is made up of rules, which are broken into two parts:  a selector, specifying the element(s) that should have the rules appliedone or more declarations, which are key/value pairs surrounded by {...} braces  h1 { color: blue; font-size: 12px; }   In this example, the selector is h1, which indicates that we want the following rules to be applied to level-1 heading elements (i.e., all &lt;h1&gt;&lt;/h1&gt; elements in the document). Next comes a list of two definitions, each ending with a ;. These declarations follow the usual key/value syntax, with a property name coming before the :, and a valuecoming after:  color: blue; says we want to use the colour (note the spelling) bluefont-size: 12px; says we want the font to be 12px.  Here's another example:  p { color: red; text-align: center; text-decoration: underline; }   This indicates we want all &lt;p&gt;&lt;/p&gt; elements in the document to have red, centered, underlined text.  ","version":"Next","tagName":"h2"},{"title":"Where to Put CSS​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#where-to-put-css","content":" CSS can come from a number of sources in an HTML page:  InlineInternal EmbeddedExternal File(s)The browser itself (e.g., default styles, or extra styles injected by a browser extension)  Browsers apply styles to elements using a priority order that matches the list above. If more than one style rule is specified for an element, the browser will prefer whatever is defined in Inline styles over Internal Embedded, Internal Embedded over External files, etc.  ","version":"Next","tagName":"h2"},{"title":"Inline Example​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#inline-example","content":" CSS rules can be placed directly on an element via the style attribute:  &lt;div style=&quot;background-color: green&quot;&gt;...&lt;/div&gt;   ","version":"Next","tagName":"h3"},{"title":"Internal Embedded​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#internal-embedded","content":" If we want to apply the same CSS rules to more than one element, it makes more sense tonot duplicate them on every element's style attribute. One solution is to use an internal embedded&lt;style&gt; element in the &lt;head&gt; or &lt;body&gt;, similar to how embedded &lt;script&gt; elements work:  &lt;style&gt; p { color: red; } div { background-color: blue; text-align: center; } &lt;/style&gt;   ","version":"Next","tagName":"h3"},{"title":"External File(s)​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#external-files","content":" Putting large amounts of CSS in &lt;style&gt; elements makes our HTML harder to read and maintain (CSS is about separating style from structure), and also causes our page to perform worse in terms of load times (i.e., the styles can't be cached by the browser). To overcome this, we often include external .css files via the &lt;link&gt;element within the document's &lt;head&gt;:  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;/html&gt;   We can include many stylesheets in this way (i.e., everything doesn't have to go in one file), and we can include .css files on the same origin, or a remote origin:  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;/html&gt;   In the example above, the page uses the popular Bootstrap CSS styles along with some locally (i.e., local to the web server) styles in styles.css.  A .css file included in this way can also @importto have even more .css files get loaded at runtime:  /* Import Font Awesome */ @import url(https://use.fontawesome.com/releases/v5.4.2/css/all.css);   In this example, the popular Font Awesome CSS library for font icons has been imported via a .css file.  ","version":"Next","tagName":"h3"},{"title":"CSS Selectors​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#css-selectors","content":" As we have seen from the above section on &quot;CSS Syntax&quot;, CSS selectors are patterns used to select elements within HTML documents for styling. They target elements based on attributes such as id, class, type, and their hierarchical relationships.  ","version":"Next","tagName":"h2"},{"title":"Tag / Type Selectors​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#tag--type-selectors","content":" The name of an HTML element can be used to specify the styles associated with all elements of the given type. For example, to indent all &lt;p&gt; text in our document, we could do this:  p { text-indent: 20px; }   ","version":"Next","tagName":"h3"},{"title":"Class Selectors​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#class-selectors","content":" Often we want to apply styles to some but not all elements of a certain kind. Perhaps we only want some of our page's &lt;p&gt; elements to have a particular look. To achieve this, we define a class, and then put that class on the elements that require it:  &lt;style&gt; .demo { text-decoration: underline red; } &lt;/style&gt; &lt;p&gt;This is a paragraph that won't get the styles below applied to it (doesn't include the class)&lt;/p&gt; &lt;p class=&quot;demo&quot;&gt;This paragraph will get the styling applied.&lt;/p&gt; &lt;p class=&quot;demo&quot;&gt;And so will this one.&lt;/p&gt;   A class can be applied to elements that aren't of the same type:  &lt;style&gt; .invisible { display: none; } &lt;/style&gt; &lt;h1 class=&quot;invisible&quot;&gt;Title&lt;/p&gt; &lt;p class=&quot;invisible&quot;&gt;This is a paragraph.&lt;/p&gt;   I this example, both the &lt;h1&gt; element, and the &lt;p&gt; element will have the display: none style applied, hiding them so they don't appear in the page.  If we want to be more specific, and only apply styles to elements of a given type which also have a given class, we can do this:  &lt;style&gt; p.note { font-weight: bold; } &lt;/style&gt; &lt;p class=&quot;note&quot;&gt;This is a paragraph that also uses the note class.&lt;/p&gt; &lt;div class=&quot;note&quot;&gt; This div uses the note class too, but because we said p.note, no styles are used. &lt;/div&gt;   An element can also have multiple classes applied, each one adding different styling:  &lt;style&gt; .invisible { display: none; } .example { color: green; background-color: red; } &lt;/style&gt; &lt;p class=&quot;invisible example&quot;&gt;This is a paragraph that uses two classes at once.&lt;/p&gt;   ","version":"Next","tagName":"h3"},{"title":"ID Selectors​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#id-selectors","content":" In many cases, we have only a single element that should use styles. Using a type or class selector would be overly broad, and so we tend to use an id instead. Recall that only one HTML element in a document can have a given id attribute: it must be unique.  &lt;style&gt; #summary { background-color: skyblue; } &lt;/style&gt; &lt;div id=&quot;summary&quot;&gt;&lt;/div&gt;   When we use the id as a selector, we prefix it with the # symbol. Notice that the HTML does not use the # symbol though.  ","version":"Next","tagName":"h3"},{"title":"Contextual Selectors​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#contextual-selectors","content":" Another common way to write selectors is to use the position of elements in the DOM. The context selector indicates the context, or placement/nesting (i.e., determined by the parent node) of the element.  For example, if we want to apply styles to &lt;p&gt; elements that are children of &lt;div&gt;elements, we could do this:  &lt;style&gt; div p { font-size: 16px; } &lt;/style&gt; &lt;p&gt;This paragraph will not receive the styling&lt;/p&gt; &lt;div&gt; &lt;p&gt;This paragraph will receive the styling.&lt;/p&gt; &lt;p&gt;This paragraph will receive the styling also.&lt;/p&gt; &lt;/div&gt;   ","version":"Next","tagName":"h3"},{"title":"Grouping Selectors​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#grouping-selectors","content":" As our CSS grows, it's common that we'll notice that we're repeating the same things multiple times. Instead of doing this, we can group a number of selectors together into a comma-separated list:  html, body { height: 100%; } h1, h2, h3, h4, h5, h6 { font-family: Serif; color: blue; }   Here we've used grouping twice to cut-down on the number of times we have to repeat things. In the first case, we defined a height of 100% (full height of the window) for the &lt;html&gt;and &lt;body&gt; elements (they don't have a height by default, and will only be as tall as the content within them). We've also declared some font and color information for all the headings we want to use.  ","version":"Next","tagName":"h3"},{"title":"Containers for Styling​","type":1,"pageTitle":"Syntax / Selectors","url":"/WebProgrammingFoundations/CSS3-Introduction/syntax-selectors#containers-for-styling","content":" We have discussed &lt;div&gt; and &lt;span&gt; when discussing HTML, but their purpose may not have been clear. Why bother wrapping other elements in &lt;div&gt;...&lt;/div&gt; or &lt;span&gt;...&lt;/span&gt; when they don't change their appearance (ie: no default style applied to them)?  With CSS we can now start to take advantage of these elements as &quot;containers&quot;, which can be used for grouping elements together for styling.  Recall that a &lt;div&gt; is a block level element, and &lt;span&gt; an inline element. Depending on how we want to group the elements and how we should apply CSS, we can use one or both. Consider the following:  &lt;style&gt; .info-box { border: solid green; } .info-box p { font-family: Serif; } .info-box span { font-weight: bold; } .info-box img { width: 75px; height: 75px; } &lt;/style&gt; &lt;p&gt;This paragraph won't have any special style applied. Neither will this &lt;span&gt;span&lt;/span&gt;.&lt;/p&gt; &lt;div class=&quot;info-box&quot;&gt; &lt;p&gt;&lt;span&gt;Name:&lt;/span&gt; Thomas Lee&lt;/p&gt; &lt;p&gt;&lt;span&gt;Age:&lt;/span&gt; 23&lt;/p&gt; &lt;img src=&quot;tlee.jpg&quot; /&gt; &lt;/div&gt;  ","version":"Next","tagName":"h2"},{"title":"Middleware","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#getting-started","content":" To implement middleware in our servers, we will begin by writing a simple middleware function that logs every request to the console. This function will be placed before any of our route handlers, ensuring that it gets executed for every request:  app.use((req, res, next) =&gt; { console.log(`Request from: ${req.get('user-agent')} [${new Date()}]`); next(); });   Notice how we make use of the aforementioned app.use() method to implement our middleware function. It looks very similar to a regular route handler, except it accepts a third parameter: next and (in this case) does not return anything to the client. It is because this function does not return anything to the client (ie: generate a &quot;response&quot;), that we must use the &quot;next()&quot; function - it simply calls the next middleware function, such as a route handler, ie:  app.get('/', (req, res) =&gt; { res.send('Hello World'); });   NOTE: If we fail to invoke the next() function or return a response, our server will hang and the client request will timeout.  ","version":"Next","tagName":"h2"},{"title":"Updating \"req\"​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#updating-req","content":" Let's continue the example by updating the &quot;req&quot; object in our middleware example to include a &quot;log&quot; property that simply stores the output of the log entry as a string. We can use this value in a subsequent route handler and send it back to the client, ie:  app.use((req, res, next) =&gt; { let loggedItem = `Request from: ${req.get('user-agent')} [${new Date()}]`; console.log(loggedItem); req.log = loggedItem; next(); }); app.get('/', (req, res) =&gt; { res.send(`Hello - ${req.log}`); });   ","version":"Next","tagName":"h3"},{"title":"Restricting Route Access​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#restricting-route-access","content":" Another common use for middleware is to restrict route access for a specific route. This can be be accomplished by placing your middleware function as a parameter to the route handling function that requires restricted access. For example:  function randomDeny(req, res, next) { let allowed = Math.floor(Math.random() * 2); // 0 or 1 if (allowed) { next(); } else { res.status(403).send('Access Denied'); } } app.get('/secure', randomDeny, (req, res) =&gt; { res.send('Welcome!'); });   Here, we have implemented our middleware function as &quot;randomDeny&quot;, which randomly generates either a 0 or 1. If a 1 is generated, the &quot;next()&quot; function is invoked, allowing the route to be processed as normal. However, if a 0 is generated, a response, including the 403 - Forbidden error code is generated, informing the user that they do not have access (we could also redirect them to a &quot;login&quot; or &quot;register&quot; page, etc).  To ensure that this middleware function only affects the &quot;/secure&quot; route, we place it as the second parameter before the callback function.  ","version":"Next","tagName":"h3"},{"title":"404 Errors​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#404-errors","content":" As a final example of how to implement middleware in our server.js code - let's create a custom &quot;404&quot; error to send to the client if it has requested an unknown route (ie: a route that we have not created a handler for):  // Other route handlers, middleware, etc ... app.use((req, res, next) =&gt; { res.status(404).send(&quot;404 - We're unable to find what you're looking for.&quot;); }); // app.listen()   Here, we have created a middleware function using the familiar &quot;use()&quot; function. However, the main difference is where it is placed, ie: below all of our other middleware functions / route handlers. By placing it in this way, we can ensure that it only gets executed if none of the other route handlers return a response to the client.  ","version":"Next","tagName":"h3"},{"title":"Types of Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#types-of-middleware","content":" Now that we have seen how middleware is typically implemented within an Express application, let's quickly review the 5 types of middleware available:  ","version":"Next","tagName":"h2"},{"title":"Application-Level Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#application-level-middleware","content":" Application-level middleware is bound to your entire application and can run when every request comes in or only when it matches a specified route.  In the examples above, we have implemented &quot;Application-level middleware&quot;.  ","version":"Next","tagName":"h3"},{"title":"Router-Level Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#router-level-middleware","content":" Router-level middleware works the same way as application middleware but is attached to a separate router instance. Essentially, instead of &quot;app.use()&quot;, a separate express.Router() instance is created and the middleware is applied to it, ie:  const userRouter = express.Router(); userRouter.use((req, res, next) =&gt; { console.log('userRouter Middleware!'); next(); });   For more information on express.Router(), see the official documentation in the official Express Routing documentation.  ","version":"Next","tagName":"h3"},{"title":"Error-Handling Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#error-handling-middleware","content":" Error-handling middleware is defined with 4 parameters in the callback function, ie: (err, req, res, next). We must specify all 4 parameters so that express can differentiate it from a regular middleware function. Error handling middleware is invoked either when a regular middleware function calls next(err) instead of next(), or when exceptions occur in your route handlers. Like our &quot;404&quot; example above, error handling middleware should be placed below your route handlers. For example:  app.get('/error-test', (req, res) =&gt; { throw new Error('Error Test'); }); app.use((err, req, res, next) =&gt; { res.status(500).send(`500 - ${err.message}`); });   ","version":"Next","tagName":"h3"},{"title":"Built-In Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#built-in-middleware","content":" There are three types of built-in middleware functions available for us to use:  express.static()​  This is what we used when sending &quot;static&quot; files (ie: &quot;css&quot; files, images, etc) in the &quot;CSS &amp; Images&quot; section of the &quot;Simple Web Server using Express.js&quot; notes, ie:  app.use(express.static('public'));   express.json()​  This is used to parse &quot;JSON&quot; formatted payloads, and make the result available on the &quot;req&quot; object. For example:  app.use(express.json()); app.post('/json-test', (req, res) =&gt; { res.send(req.body); });   express.urlencoded()​  This is nearly identical to &quot;express.json&quot;, except this is used to parse data from a web form using the default &quot;enctype&quot;, (ie: &quot;application/x-www-form-urlencoded&quot;).  NOTE: The “extended” option utilizes the &quot;qs&quot; library which enables rich objects and arrays to be encoded into the URL-encoded format, allowing for a JSON-like experience with URL-encoded. For more information, please see the qs library.  app.use(express.urlencoded({ extended: true })); app.post('/urlencoded-test', (req, res) =&gt; { res.send(req.body); });   ","version":"Next","tagName":"h3"},{"title":"Third-Party Middleware​","type":1,"pageTitle":"Middleware","url":"/WebProgrammingFoundations/Advanced-Routing-Middleware/middleware#third-party-middleware","content":" Since Express 4.x, previously included middleware that did common things such as handle cookies, or handle file uploads, have been moved to individual third-party middleware packages.  For example, parsing cookies requires the installation of cookie-parser:  $ npm install cookie-parser   const cookieParser = require('cookie-parser'); // load the cookie-parsing middleware app.use(cookieParser());   For a list of supported, third party middleware, refer to the official documentation. ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/example-code","content":"Example Code You may download the sample code for this topic here: Handling-Asynchronous-Code","keywords":"","version":"Next"},{"title":"Document Structure","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/HTML5-Introduction/document-structure","content":"","keywords":"","version":"Next"},{"title":"Terminology​","type":1,"pageTitle":"Document Structure","url":"/WebProgrammingFoundations/HTML5-Introduction/document-structure#terminology","content":" When talking about HTML's markup, we'll often refer to the following terms:  content: any text content you want to include can usually be written as-is. tag: separated from regular content, tags are special text (names) wrapped in &lt; and &gt; characters, for example the paragraph tab &lt;p&gt; or the image tag &lt;img&gt;. element: everything from the beginning of an opening tag to the closing tag, for example: &lt;h1&gt;Chapter 1&lt;/h1&gt;. Here an element is made up of an &lt;h1&gt; tag (i.e., opening Heading 1 tag), the text content Chapter 1, and a closing &lt;/h1&gt; tag. These three components taken together create an h1 element in the document. attribute: optional characteristics of an element defined using the style name or name=&quot;value&quot;, for example &lt;p id=&quot;error-message&quot; hidden&gt;There was an error downloading the file&lt;/p&gt;. Here two attributes are included with the p element: an id with value &quot;error-message&quot; (in quotes), and the hidden attribute (note: not all attributes need to have a value). Full list of common attributes. entity: special text that should not be confused for HTML markup. Entities begin with &amp; and end with ;. For example, if you need to use the &lt; character in your document, you need to use &amp;lt; instead, since &lt; would be interpreted as part of an HTML tag. &amp;nbsp; is a single whitespace and &amp;amp; is the &amp; symbol. Full list of named entities.  ","version":"Next","tagName":"h2"},{"title":"HTML Documents​","type":1,"pageTitle":"Document Structure","url":"/WebProgrammingFoundations/HTML5-Introduction/document-structure#html-documents","content":" The first HTML page ever created was built by Tim Berners-Lee on August 6, 1991.  Since then, the web has gone through many versions:  HTML - created in 1990 and standardized in 1997 as HTML 4 xHTML - a rewrite of HTML using XML in 2000 HTML5 - the current standard.  ","version":"Next","tagName":"h2"},{"title":"Basic HTML5 Document​","type":1,"pageTitle":"Document Structure","url":"/WebProgrammingFoundations/HTML5-Introduction/document-structure#basic-html5-document","content":" Here's a basic HTML5 web page:  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;My Web Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- This is a comment --&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;   Let's break this down and look at what's happening.  &lt;!doctype html&gt; tells the browser what kind of document this is (HTML5), and how to interpret/render it &lt;html&gt; the root element of our document: all other elements will be included within &lt;html&gt;...&lt;/html&gt;. &lt;head&gt; provides various information about the document as opposed to providing its content. This is metadata that describes the document to search engines, web browsers, and other tools. &lt;meta&gt; an example of metadata, in this case defining the character set used in the document: utf-8 &lt;title&gt; an example of a specific (named) metadata element: the document's title, shown in the browser's title bar. There are a number of specific named metadata elements like this. &lt;body&gt; the content of the document is contained within &lt;body&gt;...&lt;/body&gt;. &lt;!-- ... --&gt; a comment, similar to using /* ... */ in C or JavaScript &lt;h1&gt; a heading element (there are headings 1 through 6), which is a title or sub-title in a document.  ","version":"Next","tagName":"h3"},{"title":"On the Server​","type":1,"pageTitle":"Document Structure","url":"/WebProgrammingFoundations/HTML5-Introduction/document-structure#on-the-server","content":" During the last couple of classes we learned how to create a simple web server using Node.js with the Express.js module. We will be using this code once again to create a local web server, which will be responsible for returning requests for our HTML document on the default route, ie &quot;/&quot;.  NOTE: Try to familiarize yourself with these steps, as we will be doing this over and over in class, every time we wish to create a new web server. A more detailed guide can be found as a part of the Simple Web Server using Express.js documentation.  Make a directory on your computer called test-server Open Visual Studio Code and choose File &gt; Open to open your newly created test-server folder Create a new file called server.js Open the Integrated terminal useing the keyboard shortcut (ctrl + `) or select &quot;View&quot; -&gt; &quot;integrated terminal&quot; from the top menu. Run the npm init command to generate your package.json file (you can choose all of the defaults) Run the command npm install express Enter the following code for your server.js file const express = require(&quot;express&quot;); const app = express(); const HTTP_PORT = process.env.PORT || 8080; const path = require(&quot;path&quot;); // setup a 'route' to listen on the default url path app.get(&quot;/&quot;, (req, res) =&gt; { res.sendFile(path.join(__dirname,&quot;/views/hello.html&quot;)); }); // setup http server to listen on HTTP_PORT app.listen(HTTP_PORT, function(){ console.log(`server listening on: ${HTTP_PORT} )}); Create a new folder in test-server named views Within the views folder, create a file called hello.html Open the newly created hello.html file and paste the html code from above and save the file Go back to the Integrated terminal and type the command node server.js. You should see the message: &quot;server listening on: 8080&quot; Open your web browser (Chrome, Firefox, etc) and enter http://localhost:8080 in the URL bar Make sure you can see a new page with &quot;Hello World!&quot; in black text.  Updating your Document​  Go back to your editor and change the hello.html file so that instead of &quot;Hello World!&quot; you have &quot;This is my web page.&quot; Save your hello.html file. Go back to your browser and hit the Refresh button. Make sure your web page now says &quot;This is my web page.&quot;  Every time we update anything in our web page, we have to refresh the web page in our browser. The web server will serve the most recent version of the file on disk when it is requested. ","version":"Next","tagName":"h3"},{"title":"Callbacks","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/callbacks","content":"","keywords":"","version":"Next"},{"title":"Defining Functions with Callbacks​","type":1,"pageTitle":"Callbacks","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/callbacks#defining-functions-with-callbacks","content":" Now that we know that a callback is really just a function passed to another function to perform an action once some asynchronous logic is complete, let's try writing our own code. Here, we will be using the setTimeout() function to approximate an asynchronous action such as connecting to a database.  For our first example, let's say that we have a function called &quot;connectToDatabase&quot; that establishes a database connection after a random amount of time (between 1 and 2000 milliseconds). We also have a function called &quot;queryData&quot; that also takes a random amount of time to complete (in this case, it is between 1 and 1000 milliseconds).  function connectToDatabase() { let randomTime = Math.floor(Math.random() * 2000) + 1; setTimeout(() =&gt; { console.log('Connection Established'); }, randomTime); } function queryData() { let randomTime = Math.floor(Math.random() * 1000) + 1; setTimeout(() =&gt; { console.log('Query Complete'); }, randomTime); }   For our code to work correctly, we must first connect to the database, then query the data. To accomplish this, we would intuitively write the code to invoke the functions in order, ie:  connectToDatabase(); queryData();   However, this poses a problem as there's no way to ensure that the logic to connect to the database happens before the query. In fact, since it takes longer to connect to the database, it's more likely that the query logic will complete first.  One way to solve this problem is to provide the &quot;queryData()&quot; function as a callback function to &quot;connectToDatabase()&quot; to be executed once the connection has been established:  function connectToDatabase(queryFunction) { let randomTime = Math.floor(Math.random() * 2000) + 1; setTimeout(() =&gt; { console.log('Connection Established'); queryFunction(); }, randomTime); }   Notice how we have added &quot;queryFunction&quot; as a parameter to the connectToDatabase() function. Once the connection has been established, we manually invoke the function using &quot;()&quot;.  Now, we can ensure that the functions are executed in order, using the code:  connectToDatabase(queryData);   ","version":"Next","tagName":"h2"},{"title":"Adding Parameters​","type":1,"pageTitle":"Callbacks","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/callbacks#adding-parameters","content":" As our code stands now, the &quot;queryData&quot; function is very simple and does not take any parameters. Why don't we try making it a little more dynamic by adding parameters to it, so that a query can be provided:  function queryData(query) { let randomTime = Math.floor(Math.random() * 1000) + 1; setTimeout(() =&gt; { console.log(query); }, randomTime); }   Now we can invoke our queryData with a given query, for example:  queryData('select * from Employees');   However, a problem occurs when we attempt to provide the &quot;queryData&quot; function as a callback to another function (in our case, the &quot;connectToDatabase&quot; function):  connectToDatabase(queryData('select * from Employees')); // TypeError: queryFunction is not a function   This is because the &quot;()&quot; syntax after the function name causes the function to execute which then passes its return value (&quot;undefined&quot;) to the connectToDatabase function. To solve this, we must pass the parameters to the &quot;queryData()&quot; callback function, as parameters to the &quot;connectToDatabase()&quot; function:  function connectToDatabase(queryFunction, query) { let randomTime = Math.floor(Math.random() * 2000) + 1; setTimeout(() =&gt; { console.log('Connection Established'); queryFunction(query); }, randomTime); }   Here, you can see that we have added the &quot;query&quot; as a 2nd parameter to the connectToDatabase function and use it as a parameter to the &quot;queryFunction&quot;.  Putting it all together, we get:  function connectToDatabase(queryFunction, query) { let randomTime = Math.floor(Math.random() * 2000) + 1; setTimeout(() =&gt; { console.log('Connection Established'); queryFunction(query); }, randomTime); } function queryData(query) { let randomTime = Math.floor(Math.random() * 1000) + 1; setTimeout(() =&gt; { console.log(query); }, randomTime); } connectToDatabase(queryData, 'select * from Employees');  ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/HTML5-Introduction/example-code","content":"Example Code You may download the sample code for this topic here: HTML5-Introduction","keywords":"","version":"Next"},{"title":"Units & Properties","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties","content":"","keywords":"","version":"Next"},{"title":"CSS Units​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#css-units","content":" The most common units we use in CSS are:  1em = 12pt = 16px = 100%   Let's look at each of these in turn:  em (the width of the capital letter M) - a scalable unit that is used in web media, and is equal to the current font-size. If the font-size is 12pt, 1em is the same as 12pt. If the font-size is changed, 1em changes to match. We can also use multiples: 2em is twice the font-size, and .5em is half. Using em for sizes is popular on the web, since things have to scale on mobile vs. desktop (i.e., fixed unit sizes don't work as the screen shrinks/expands). pt - a fixed-size Point unit that comes from print media, where 1pt equals 1/72 of an inch. px - pixels are fixed size units for web media (screens), and 1px is equal to one dot on a computer display. We use px on the web when we need &quot;pixel perfect&quot; sizing (e.g., image sizes). % - the percent unit is similar to em in that it scales with the size of the display. 100% is the same as the current font-size. vw, vh - the viewport width and height units are percentages of the visible space in the viewport (the part of the page you can see, the window's width and height). 1vw is the same as 1% of the width of the viewport, and 80vh is the same as 80% of the visible height.  You will also sometimes encounter other ways of measurement that use full words: xx-small, x-small, small, medium, large, x-large, xx-large, smaller, larger, thin, medium, thick  Here's an example that uses a number of the units mentioned above:  &lt;style&gt; html, body { height: 100vh; } .box { margin: 10px; font-size: 2em; height: 150px; border: medium solid black; } &lt;/style&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;   ","version":"Next","tagName":"h2"},{"title":"CSS Colours (color)​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#css-colours-color","content":" CSS allows us to define colour values for many declarations. We do so by specifying a colour using one of the following notations:  Hexadecimal Red, Green, Blue: written using 3 double-digit hex numbers, and starting with a # sign. Each of the 3 pairs represents a value between 0 and 255 for Red, Green, and Blue: #000000 is pure Black and #ffffff is pure White, and #ffd700 is Gold. RGB or RGBA notation: here the red, green, blue, and sometimes alpha (i.e., opacity) are defined in decimal notation: #ffffff is the same as rgb(255, 255, 255) and #ffd700 is the same as rgb(255, 215, 0). If we want to define how see-through the colour is (by default you can't see through a colour), we add an alpha value: rgba(0, 191, 0, 0.5) means that the colour will be 50% see through. Named colours: some colours are so common that they have their own name defined in the CSS standard. For example: white, black, green, red, but also chocolate, darkorange, peru, etc.  The easiest way to understand this is using a Colour Picker tool, which lets you visually see the difference in changing values.  ","version":"Next","tagName":"h2"},{"title":"CSS Properties and Values​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#css-properties-and-values","content":" A property is assigned to a selector in order to manipulate its style. The CSS properties are defined as part of the CSS standard. When you want to know how one of them works, or which values you can assign, you can look at the documentation on MDN. For example:  text-indentcolorbackground-colorborder  There are hundreds of properties we can tweak as web developers, and it's a good idea to explore what's available, and to look at how other web sites use them via the developer tools.  A property can have one or more values. A the possible values a property can have also comes from the standard. For example:  p { text-decoration: underline; } .spelling-error { text-decoration: red wavy underline; }   The text-decoration property is defined to take one of a number of values, each of which is also defined in the standard.  ","version":"Next","tagName":"h2"},{"title":"Exploring CSS Properties and Values in the Dev Tools​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#exploring-css-properties-and-values-in-the-dev-tools","content":" By far the best way to learn about CSS is to look at how other sites use it. When you find something on the web that you think looks interesting, open your browser's dev tools and inspect the CSS Styles:    You can look at the specific properties specified for an element, or see all the computed styles (i.e., everything, including all default values). You can also try toggling these on and off, or double-click the values to enter your own.  ","version":"Next","tagName":"h2"},{"title":"CSS text Properties​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#css-text-properties","content":" There are dozens of properties that affect how text is rendered. These include things like the color, spacing, margins, font characteristics, etc.  h2 { color: red; text-align: center; text-decoration: underline; text-transform: uppercase; } p { color: #0000ff; text-indent: 100px; }   ","version":"Next","tagName":"h2"},{"title":"font Properties​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#font-properties","content":" We can use the font-family property to specify a font, or list of fonts, for the browser to apply to an element. The font must be available on the user's computer, otherwise the next font in the list will be tried until one is found that is installed, or a default font will be used.  In general it is safe to assume that the following fonts are available:  Helvetica, Arial, Verdana, sans-serif - sans-serif fonts&quot;Courier New&quot;, Courier, monospace - monospace fontsGeorgia, &quot;Times New Roman&quot;, Times, serif - serif fonts  You can see a list of the fonts, and OS support here.  h3 { font-family: Arial; } h4 { font-family: 'Times New Roman', Times, serif; } h5 { font-size: 18pt; font-style: italic; font-weight: 500; }   ","version":"Next","tagName":"h3"},{"title":"Web Fonts - @font-face​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#web-fonts---font-face","content":" Modern browsers also allow custom fonts to be included as external files, and downloaded as needed by the web site. This is often the preferred method for designers, who don't want to be limited to the set of fonts available on all operating systems.  A font is a file that describes the curves and lines needed to generate characters at different scales. There are various formats, from OTF (OpenType Format) toTTF (TrueType Format) to WOFF (Web Open Font Format), etc. In order for the browser to use a new font, it has to be downloadable via one or more URLs. We then tell the browser which font files to download in our CSS via the@font-face property:  @font-face { font-family: &quot;FontName&quot; src: url(font.woff2) format('woff2'), url(font.ttf) format('truetype'); } body { font-family: &quot;FontName&quot;; }   Many fonts have to be purchased, but there are some good sources of high quality, freely available fonts for your sites:  Font Squirreldafont.comGoogle Fonts  For example, we can use the popular &quot;Lobster&quot; font from Google by doing the following in our CSS:  @import url(https://fonts.googleapis.com/css?family=Lobster); p { font-family: 'Lobster'; }   ","version":"Next","tagName":"h3"},{"title":"font-size property​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#font-size-property","content":" Using the font-size property, font sizes can be given in fixed or relative units, depending on how we want our text to scale on different devices:  h1 { font-size: 250%; /* scaled to 250% of regular font size */ } p { font-size: 20pt; /* size in points -- 20/72 of an inch */ } .quote { font-size: smaller; /* smaller than normal size */ } .bigger { font-size: 1.5em; /* 1.5 times larger than the 'M' in normal font size */ }   ","version":"Next","tagName":"h3"},{"title":"Text Effects​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#text-effects","content":" There are numerous effects that can be added to text (or any element), many beyond the scope of this initial exploration of CSS. Here are a few simple examples to give you an idea  text-shadow allows a shadow to be added to text, giving it a 3-D style appearance. The value includes a colour,x and y offsets that determine the distance of the shadow from the text. Finally, we can also add a blur-radius, indicating how much to blur the shadow.  .shadow-text { text-shadow: 1px 1px 2px pink; }   text-overflow can be used to determine what the browser should do when the amount of text exceeds the available space in a container (e.g. in a &lt;div&gt; or &lt;p&gt; that isn't wide enough). For example, we can specify that we want to clip the contents and not show any more, or we can automatically display ..., the ellipsis.  &lt;style&gt; .movie-title { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } &lt;/style&gt; &lt;p class=&quot;movie-title&quot;&gt;Pirates of the Caribbean: The Curse of the Black Pearl&lt;/p&gt;   ","version":"Next","tagName":"h3"},{"title":"background Properties​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#background-properties","content":" Every element has a background that we can modify. We might, for example, want to specify that the background be a certain colour; or we might want to use an image, or even tile an image multiple times (like wallpaper to create a pattern); or we might want to create a gradient, from one colour to another. All of these options and more are possible using the backgroundproperty.  div.error { background: red; } div.wallpaper { background: url('pattern.jpg') repeat; }   ","version":"Next","tagName":"h2"},{"title":"Styling Links​","type":1,"pageTitle":"Units & Properties","url":"/WebProgrammingFoundations/CSS3-Introduction/units-properties#styling-links","content":" We can control the way that links (i.e., &lt;a&gt;) appear in our document. By default they will have a solid blue underline, and when visited, a purple solid underline. If you want to remove the underline, or change it's colour to match the theme of a page, we can do that using CSS pseudo-classes.  With pseudo-classes we can specify certain states for the elements in our selector, for example:  a:link - a normal, unvisited link (normally blue underline)a:visited - a link the user has visited previously (normally purple underline)a:hover - a link when hovered with the mousea:active - a link when it is clicked (i.e., while the mouse button is pressed)  NOTE: pseudo-classes can be used with any element, but we mention them here in relation to styling links, since we often need them to deal with different states for a link.  Let's alter our links so that they use blue text, with no underline. However, when hovered, add back the underline:  a:link, a:visited { text-decoration: none; } a:hover, a:active { text-decoration: underline; }  ","version":"Next","tagName":"h2"},{"title":"Developer Tools & Core Technologies","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies","content":"","keywords":"","version":"Next"},{"title":"Visual Studio Code​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#visual-studio-code","content":"   “Visual Studio Code is an open-source (free) streamlined code editor with support for development operations like debugging, task running and version control. It aims to provide just the tools a developer needs for a quick code-build-debug cycle and leaves more complex workflows to fuller featured IDEs”. Visual Studio Code also runs on Mac OS X, Linux and Windows operating systems, which will provide the class with a single unified environment to work in regardless of a student’s choice of laptop or home computer. Some of the noteworthy features of Visual Studio Code Include:  ","version":"Next","tagName":"h2"},{"title":"Integrated Terminal​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#integrated-terminal","content":" “In Visual Studio Code, you can open an integrated terminal, initially starting at the root of your workspace. This can be very convenient as you don’t have to switch windows or alter the state of an existing terminal to perform a quick command line task”.  To open the terminal:  Use the keyboard shortcut Ctrl + `Use the View | Toggle Integrated Terminal menu command.  ","version":"Next","tagName":"h3"},{"title":"Smart Editing​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#smart-editing","content":" VS Code comes with a built-in JavaScript language service so you get JavaScript code intelligence out-of-the-box. Language services provide the code understanding necessary for features like:  IntelliSense: (suggestions)smart code navigation (Go to Definition, Find All References, Rename Symbol)  ","version":"Next","tagName":"h3"},{"title":"File & Folder Based​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#file--folder-based","content":" Since VS Code is file and folder based – you can get started immediately by simply opening a file or folder in VS Code.  “On top of this, VS Code can read and take advantage of a variety of project files defined by different frameworks and platforms. For example, if the folder you opened in VS Code contains one or more package.json (which we will be making extensive use of during the semester), project.json, tsconfig.json, or .NET Core Visual Studio solution and project files, VS Code will read these files and use them to provide additional functionality, such as rich IntelliSense in the editor”.  ","version":"Next","tagName":"h3"},{"title":"Version Control​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#version-control","content":" Visual Studio Code has integrated Git support for some of the most common commands, making it easy to verify and commit code changes (see &quot;Git&quot; below).  ","version":"Next","tagName":"h3"},{"title":"Modern Web Browser​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#modern-web-browser","content":"  A modern web browser such as Google Chrome or Mozilla Firefox will be used regularly throughout this course. Microsoft Edge will work as well, as it supports a similar set of development tools, however due to it’s lack of plugins / addons and cross-platform support it’s not as highly recommended. All screenshots and development examples used throughout this course have been taken in Google Chrome.  ","version":"Next","tagName":"h2"},{"title":"Browser Developer Toolbar​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#browser-developer-toolbar","content":" Before starting this course, students should have at least a basic understanding of the Developer Tools built into a modern web browser. Typically, pressing the F12 Key (Windows) will open the bar, however there are alternate ways of opening it. For Google chrome:  Open the Chrome menu at the top-right of your browser window, then select Tools &gt; Developer Tools.Right-click on any page element and select Inspect.  This will bring up the Chrome “Developer Toolbar”, as seen below :    We will be working with many of these panels throughout the semester. A quick list of their functionality (from left to right, starting at the top left corner) is as follows:  Icon\tDescription\tElement Inspector: Select an element in the page to inspect it; this will cause the Developer Tools (Devtools) to switch to the “Elements” panel and highlight the rendered source code (HTML) responsible for displaying the item. This will also cause the “Styles” panel (on the right) to highlight all current CSS applied to the element. Device Toolbar Toggle: Toggles the “device toolbar” on and off. This allows the developer to select a device and manually enter the pixel dimensions of the screen and scale of the page. This is useful for ensuring that the page looks correct on a variety of devices. Elements Panel: Shows a view of the current page’s Document Object Model (DOM) tree as HTML. Selecting a given node (element) will highlight it in the page and show it’s applied CSS in the “Styles” panel. Developers can also modify this element and corresponding CSS (“Styles” panel) live and see the results directly in the browser. Important Note: The HTML shown in this panel isn’t necessarily the source code of the page, as it will show elements and attributes that have been dynamically added after the page is loaded. Changes to the HTML/CSS/JavaScript in this mode will not save to the source file. Sources Panel: Shows a list of all items included in the page (i.e., all images, CSS, JavaScript, etc.) and their corresponding locations of origin. Developers can click on an item to show its contents in the middle (preview) panel. If the selected item is a JavaScript file, developers can (in the “debugger” panel) set breakpoints and watch variables to help identify and debug a misbehaving piece of JavaScript code. Console Panel: Shows a JavaScript console pane. JavaScript calls to console.log() will show the resultant text in this window. Additionally, all JavaScript errors will show up in this location in red. Developers can also write small JavaScript code snippets to be executed immediately within the context of the page. Network Panel: Is used to get additional insights into requested and downloaded resources. Developers can view a log that tracks all resources loaded including their corresponding status code, type, time (latency), size of the resource and the initiator of the request. Performance Panel: Enables a tool that allows developers to record and analyze all the activity in their applications as they run. It’s the best place to start investigating perceived performance issues. This is done by recording a timeline of every event that occurs after a page loads and analyzing the corresponding FPS, CPU, and network requests. Memory Panel: Provides more detailed debugging information than the timeline by enabling developers to record detailed CPU/Memory profiles such as a “Heap Snapshot”, “Allocation instrumentation on timeline&quot;, and “Allocation sampling&quot;. Application Panel: Allows developers to inspect and manage client-side storage, caches, and resources. This includes: key-value pairs stored in “Local Storage”, access to IndexedDB Data (a JavaScript-based object-oriented database used to store data locally), a “Web SQL” explorer (deprecated in favor of IndexedDB), as well as access to stored cookies and cache data. This is very useful in verifying that your application is storing data correctly on the client side. Security Panel: Gives an overview of a page from a security standpoint including: Certificate verification (indicating whether the site has proven its identity with a TLS certificate), Transport Layer Security (TLS) connection (Note: TLS is often referred to by the name of its predecessor, SSL), and Subresource security (indicating whether the site loads insecure HTTP subresources – i.e., “mixed content”). Error Icon: Displays the number of errors present in the “Console Pane”. To review the errors, simply switch over to the Console pane and locate the items highlighted in red. Customize Icon: Controls where the Developer Toolbar should be placed relative to the browser, as well as a collection of all related settings and preferences for the tool set. Close Icon: Closes the Developer Toolbar.  ","version":"Next","tagName":"h3"},{"title":"Core Technologies​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#core-technologies","content":" Additionally, we will cover a number of topics surrounding the following technologies (in no particular order):  ","version":"Next","tagName":"h2"},{"title":"JavaScript (ECMAScript)​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#javascript-ecmascript","content":"   A huge focus of this course will be on JavaScript. In fact – JavaScript will be the only official programming language that we will be studying in this course. While we will be interacting with HTML5 and CSS3, neither is considered a “programming language” in the same way that C, C++ or JavaScript is. HTML5 and CSS3 are instead considered markup languages and style sheet languages respectfully – that is, they describe presentation, whereas programming languages describe function. Regardless, we will be focusing exclusively on JavaScript and how a number of very sophisticated tools and frameworks can help us create efficient and functional web applications.  ECMAScript  Back in 1996 the JavaScript language specification was taken to Ecma (European Computer Manufacturers Association) International to develop a formal standardized specification, which other browser vendors and companies could implement and expand upon. This standardized JavaScript was dubbed “ECMAScript” and specific vendor versions of the specification were known as “dialects”, the most popular of which being “JavaScript”. When we refer to “JavaScript” we’re really referring to a dialect of ECMAScript that has been implemented in the engine / runtime environment that is running our JavaScript formatted code. For example, this includes JavaScript engines like SpiderMonkey in Firefox and v8 in Chrome.  In 2015, ECMAScript 6 was released and many important features were introduced, such as:  Arrow FunctionsClass DefinitionsBlock Scoped VariablesPromisesBinary &amp; Octal literalsModulesand many more…  Since then, development of ECMAScript has continued and new versions are released yearly. For a comprehensive list of which features are supported in specific browsers, environments and runtimes, see:  ECMAScript Compatibility Table  ","version":"Next","tagName":"h3"},{"title":"Node.js​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#nodejs","content":"   At it’s core, Node.js is an open-source, cross-platform JavaScript runtime environment built on Chrome’s V8 JavaScript engine. It is typically used for developing server-side and networking applications and has exploded as the go-to application framework for many real-time web applications. This is largely due to it’s event-driven, non-blocking I/O model which ensures that the main thread of execution is not kept waiting for slow I/O operations (ie: stopping and waiting for a database query to complete). Some major companies using it include Paypal, eBay, GoDaddy, Microsoft, Shutterstock, Uber, Wikia just to name a few.  Node.js also has an expansive package ecosystem accessible via it’s Node Package Manager (NPM) utility. We will leverage this by experimenting with a number of popular, open-source modules including:  Express.js (http://expressjs.com)EJS (https://ejs.co)Multer (https://github.com/expressjs/multer)Sequelize (https://sequelize.org)Helmet (https://helmetjs.github.io)  ","version":"Next","tagName":"h3"},{"title":"Git​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#git","content":"   We will be using Git: a command-line tool which serves as a version control system used for tracking changes to your source code and making it available for collaboration with other developers (by leveraging online tools such as Github or GitLab). Additionally, there are many online services that connect to your published code to 3rd party cloud platforms such as Render or Netlify which can build your code and host your web application. For this class, we will be using Vercel - please see the Vercel Guide for more information.  There is a ton of information online on how to get started using Git / GitHub, such as:  An Intro to Git and GitHub for Beginners (Tutorial)Pro Git (eBook)Git and GitHub learning resources  ","version":"Next","tagName":"h3"},{"title":"PostgreSQL​","type":1,"pageTitle":"Developer Tools & Core Technologies","url":"/WebProgrammingFoundations/Introduction/developer-tools-core-technologies#postgresql","content":"   From the PostgreSQL site, postgresql.org:  “PostgreSQL (also known as “Postgres”) is a powerful, open source object-relational database system. It has more than 15 years of active development and a proven architecture that has earned it a strong reputation for reliability, data integrity, and correctness. It runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, macOS, Solaris, Tru64), and Windows. It is fully ACID compliant, has full support for foreign keys, joins, views, triggers, and stored procedures (in multiple languages). It includes most SQL:2008 data types, including INTEGER, NUMERIC, BOOLEAN, CHAR, VARCHAR, DATE, INTERVAL, and TIMESTAMP. It also supports storage of binary large objects, including pictures, sounds, or video. It has native programming interfaces for C/C++, Java, .Net, Perl, Python, Ruby, Tcl, ODBC, among others, and exceptional documentation. ","version":"Next","tagName":"h3"},{"title":"Welcome to Web Programming Foundations","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Introduction/welcome","content":"Welcome to Web Programming Foundations Welcome to Web Programming Foundations. In this course, we will learn some of the foundational skills necessary to build and deploy scalable Web Applications that leverage current technologies such as Node.js, Express.js, HTML5 / CSS3, EJS and Postgres. This will involve studying: foundational knowledge of JavaScript (ECMAScript 6, ie: ES6), the Node.js JavaScript Runtime, the Express.js web application framework, the HTTP Protocol, HTML5 / CSS3, Database connectivity and finally, an introduction to web security. Before we get started, please have a look around the site and familiarize yourself with the content. If you’re looking to get started right away, the “Hello World&quot; is a great place to start.","keywords":"","version":"Next"},{"title":"Promises & Async / Await","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await","content":"","keywords":"","version":"Next"},{"title":"Callback Review​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#callback-review","content":" As a quick review of the callback logic discussed earlier, consider the following three functions:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('A'); }, randomTime); } // output &quot;B&quot; after a random time between 0 &amp; 3 seconds function outputB() { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('B'); }, randomTime); } // output &quot;C&quot; after a random time between 0 &amp; 3 seconds function outputC() { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('C'); }, randomTime); }   If we were to execute them in order, ie:  outputA(); outputB(); outputC();   we would have no idea which letter would be output to the console first (&quot;A&quot;, &quot;B&quot;, or &quot;C&quot;), since each function takes a random amount of time to complete. If however, we wanted to be absolutely sure that the output of the code is in the correct order (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) regardless of how long it takes each function to execute, we must ensure that the &quot;follow up&quot; functions are passed as parameters to the functions with the asynchronous logic (ie: &quot;callbacks&quot;). This case is more complicated because we have 3 functions, however it can still be achieved using the following code:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA(firstCallback, secondCallback) { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('A'); firstCallback(secondCallback); }, randomTime); } // output &quot;B&quot; after a random time between 0 &amp; 3 seconds function outputB(lastCallback) { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('B'); lastCallback(); }, randomTime); } // output &quot;C&quot; after a random time between 0 &amp; 3 seconds function outputC() { let randomTime = Math.floor(Math.random() * 3000) + 1; setTimeout(() =&gt; { console.log('C'); }, randomTime); } // invoke the functions in order outputA(outputB, outputC);   In the above code, we have ensured the correct flow of execution of the three functions by passing both follow up functions to the first function as parameters. The final function is then passed to the second function as a callback, so that it may be executed in the right order.  While this does indeed work to solve the intended problem (getting the output to happen in order: &quot;A&quot;, &quot;B&quot; then &quot;C&quot;), we have created some code which is difficult to follow, maintain and scale. For example, what happens when we add an &quot;outputD()&quot; function? We would need to pass it as well to the outputA() function as a parameter, only to get passed down the chain until it is executed in the correct context (for example, after outputC() has completed). As you can imagine, this creates a problem in our code and leaves us asking: &quot;is there a better way?&quot;  ","version":"Next","tagName":"h2"},{"title":"Promises​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#promises","content":" ","version":"Next","tagName":"h2"},{"title":"Resolve & Then​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#resolve--then","content":" Fortunately, JavaScript has the notion of the &quot;Promise&quot; that can help us deal with this type of situation. Put simply, a promise object is used for asynchronous computations (like the situation in the example above) and represents a value which may be available now, or in the future, or never. Basically, what this means is that we can place our asynchronous code inside a promise object as a function with specific parameters (&quot;resolve&quot; and &quot;reject&quot;). When our code is complete, we invoke the &quot;resolve&quot; function and if our code encounters an error, we can invoke the &quot;reject&quot; function. We can handle both of these situations later with the .then() method or (in the case of an error that we wish to handle) the .catch() method. To see how this concept is implemented in practice, consider the following addition to the outputA() method from above:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { // place our code inside a &quot;Promise&quot; function setTimeout(() =&gt; { console.log('A'); resolve(); // call &quot;resolve&quot; because we have completed the function successfully }, randomTime); }); } // call the outputA function and when it is &quot;resolved&quot;, output a confirmation to the console outputA().then(() =&gt; { console.log('outputA resolved!'); });   Our &quot;outputA()&quot; function still behaves as it did before (outputs &quot;A&quot; to the console after a random period of time). However, our outputA() function now additionally returns a new Promise object that contains all of our asynchronous logic and its status. The container function for our logic always uses the two parameters mentioned above, ie: resolve and reject. By invoking the resolve method we are placing the promise into the fulfilled state, meaning that the operation completed successfully and the character &quot;A&quot; was successfully output to the console. We can respond to this situation using the &quot;then&quot; function on the returned promise object to execute some code after the asynchronous operation is complete! This gives us a mechanism to react to asynchronous functions that have completed successfully so that we can perform additional tasks.  ","version":"Next","tagName":"h3"},{"title":"Adding Data​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#adding-data","content":" Now that we have the promise structure in place and are able to &quot;resolve&quot; the promise when it has completed it's task and &quot;then&quot; execute another function using the returned promise object (as above), we can begin to think about how to pass data from the asynchronous function to the &quot;then&quot; method. Fortunately, it only requires a little tweak to the above the above example to enable this functionality:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { // place our code inside a &quot;Promise&quot; function setTimeout(() =&gt; { console.log('A'); resolve('outputA resolved!'); // call &quot;resolve&quot; because we have completed the function successfully }, randomTime); }); } // call the outputA function and when it is &quot;resolved&quot;, output a confirmation to the console outputA().then((data) =&gt; { console.log(data); });   Notice how we are able to invoke the resolve() function with a single parameter that stores some data (in this case a string with the text &quot;outputA resolved!&quot;). This is typically where we would place our freshly returned data from an asynchronous call to a web service / database, etc. The reason for this is that we will have access to it as the first parameter to the anonymous function declared inside the .then method and this is the perfect place to process the data.  ","version":"Next","tagName":"h3"},{"title":"Reject & Catch​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#reject--catch","content":" It is not always safe to assume that our asynchronous calls will complete successfully. What if we're in the middle of a request and our connection is dropped or a database connection fails? To ensure that we handle this type of scenario gracefully, we can invoke the &quot;reject&quot; method instead of the &quot;resolve&quot; method and provide a reason why our asynchronous operation failed. This causes the promise to be in a &quot;rejected&quot; state and the &quot;.catch&quot; function will be invoked, where we can gracefully handle the error. The typical syntax for handling both &quot;then&quot; and &quot;catch&quot; in a promise is as follows:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { // place our code inside a &quot;Promise&quot; function setTimeout(() =&gt; { console.log('-'); reject('outputA rejected!'); // call &quot;reject&quot; because the function encountered an error }, randomTime); }); } // call the outputA function and when it is &quot;resolved&quot; or &quot;rejected, output a confirmation to the console outputA() .then((data) =&gt; { console.log(data); }) .catch((reason) =&gt; { console.log(reason); });   NOTE: Calling &quot;resolve()&quot; or &quot;reject()&quot; won't immediately exit the promise and invoke the related &quot;.then()&quot; or &quot;.catch()&quot; callback - it simply puts the promise in a &quot;resolved&quot; or &quot;rejected&quot; state and code immediately following the statement will still run, ie: // ... reject(); console.log('I will still be executed'); resolve(); // This promise will not be &quot;resolved&quot;, since the resolve() call came after reject() // this also works the other way around. A promise has been &quot;settled&quot; once reject or resolve has been called // ... If we want to immediately exit the function and prevent further execution of the code within the promise, we can invoke the &quot;return&quot; statement, immediately following the &quot;resolve()&quot; or &quot;reject()&quot; call, ie: // ... reject(); return; console.log('I will not be executed'); // ...   ","version":"Next","tagName":"h3"},{"title":"Putting it Together​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#putting-it-together","content":" Now that we know how the promise object and pattern can help us manage our asynchronous code, let's loop back to our original problem - ensuring that &quot;A&quot;, &quot;B&quot; and &quot;C&quot; are output in the correct order when invoking the &quot;outputA()&quot;, &quot;outputB()&quot; and &quot;outputC()&quot; functions, respectfully.  To make it more interesting, we will alter our code such that each of the functions resolve with the value if the randomTime is odd and reject with an error if randomTime is even:  // output &quot;A&quot; after a random time between 0 &amp; 3 seconds function outputA() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { randomTime % 2 ? resolve('A') : reject('Error with outputA()'); }, randomTime); }); } // output &quot;B&quot; after a random time between 0 &amp; 3 seconds function outputB() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { randomTime % 2 ? resolve('B') : reject('Error with outputB()'); }, randomTime); }); } // output &quot;C&quot; after a random time between 0 &amp; 3 seconds function outputC() { let randomTime = Math.floor(Math.random() * 3000) + 1; return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { randomTime % 2 ? resolve('C') : reject('Error with outputC()'); }, randomTime); }); }   If we wish to use the promises correctly to output the values in order and correctly handles errors, our code looks like the following (this is known as promise &quot;chaining&quot;):  outputA() .then((data) =&gt; { console.log(data); // output the result of &quot;outputA()&quot; to the console return outputB(); }) .then((data) =&gt; { console.log(data); // output the result of &quot;outputB()&quot; to the console return outputC(); }) .then((data) =&gt; { console.log(data); // output the result of &quot;outputC()&quot; to the console }) .catch((err) =&gt; { console.log(err); // output the error to the console });   Success! We always have &quot;A&quot;, followed by &quot;B&quot; and &quot;C&quot; in the console and the errors are correctly handled when they occur (preventing the subsequent promises from executing). We have the benefit of not having to alter the functions themselves at all if follow-up logic is necessary. Each function simply does its job, then reports back with the data (&quot;resolves&quot;) if it was successful or sends the error (&quot;rejects&quot;) it failed. This is a much more maintainable, scalable and cleaner approach to working with asynchronous code. This is why you will find that most modules mentioned in these notes are &quot;promise-based&quot;, ie: if their logic is asynchronous, functions provided by the module will return Promise objects.  While functions that return promises are indeed the preferred way to work with asynchronous operations in JavaScript, as you can see from the above code, working with promises can sometimes be difficult. If we wish to chain promises (in the case above) We must ensure that for every &quot;then()&quot; callback function returns the correct follow up function and it can be difficult to visually walk through the code.  ","version":"Next","tagName":"h3"},{"title":"Async & Await​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#async--await","content":" To help us work with promises more easily in JavaScript, ECMAScript 2016 (ES7) released async &amp; await as an alternative to using &quot;then()&quot; and &quot;catch()&quot;  ","version":"Next","tagName":"h2"},{"title":"Putting it Together (again)​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#putting-it-together-again","content":" Knowing that there is an alternative to &quot;then()&quot; and &quot;catch()&quot;, let's see how we can re-write the section of &quot;Putting it Together&quot; that makes use of the promises (we will not alter the functions themselves) using &quot;async&quot; and &quot;await&quot;. To achieve this, we must place our logic inside a function, ie &quot;showOutput()&quot; - the reason for this will be described below:  async function showOutput() { try { let A = await outputA(); console.log(A); // output the result of &quot;outputA()&quot; to the console let B = await outputB(); console.log(B); // output the result of &quot;outputB()&quot; to the console let C = await outputC(); console.log(C); // output the result of &quot;outputC()&quot; to the console } catch (err) { console.log(err); // output the error for outputA(), outputB() or outputC() to the console } } showOutput();   This is much cleaner and easier to read. By using the &quot;await&quot; operator, we're essentially saying &quot;wait for this function's returned promise to resolve&quot;. Additionally, you can see that we actually get the resolved value from the promise!  ","version":"Next","tagName":"h3"},{"title":"Using Await​","type":1,"pageTitle":"Promises & Async / Await","url":"/WebProgrammingFoundations/Handling-Asynchronous-Code/promises-async-await#using-await","content":" &quot;await&quot; pauses the execution of its surrounding async function until the promise is settled (that is, fulfilled or rejected). When execution resumes, the value of the await expression becomes that of the fulfilled promise. If the promise is rejected, the await expression throws the rejected value. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await  Notice how the documentation mentions the &quot;surrounding async function&quot;. This is because to actually use the &quot;await&quot; operator, it must be placed within a function marked as &quot;async&quot;. If we fail to do this and try to use await outside of an async function, we will get an error:  SyntaxError: await is only valid in async functions and the top level bodies of modules   You will also notice how the documentation mentions that if the promise is rejected, the await expression &quot;throws the rejected value&quot;. This is why we must place our &quot;await&quot; logic within a &quot;try&quot; / &quot;catch&quot; block. If we fail to do so and one of the promise-based functions is actually rejected, we will get the following error (NOTE: this error also occurs if a &quot;.catch()&quot; function is missing when using then() &amp; catch()):  UnhandledPromiseRejection: This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch().   NOTE: When using &quot;async&quot; to identify a function, you are implicitly returning a Promise. This is because async functions cannot exist within the normal flow of execution (since they contain asynchronous code). If you do return a value from an &quot;async&quot; function, it will be the &quot;resolved&quot; value of the returned promise: async function adder(num1, num2) { return num1 + num2; } adder(1, 2).then((result) =&gt; console.log(result)); //3  ","version":"Next","tagName":"h3"},{"title":"HTML Elements","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements","content":"","keywords":"","version":"Next"},{"title":"Metadata​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#metadata","content":" Information about the document itself (not the document's actual content) goes in various metadata elements. These types of elements must be included within the &lt;head&gt; element:  &lt;link&gt; - links from this document to external resources, such as CSS stylesheets&lt;meta&gt; - metadata that can't be included via other elements&lt;title&gt; - the document's title  ","version":"Next","tagName":"h2"},{"title":"Element Types (Block vs. Inline)​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#element-types-block-vs-inline","content":" Before we discuss some of the main visual HTML elements, we must introduce two important distinctions:  Block-level elements: create a &quot;block&quot; of content in a page, with an empty line before and after them. Block elements expand to fill the width of their parent element. Block elements can contain other block elements, inline elements, or text. Inline elements: creates &quot;inline&quot; content, which is part of the containing block. Inline elements can contain other inline elements or text.  Consider the following HTML content:  &lt;body&gt; &lt;p&gt;The &lt;em&gt;cow&lt;/em&gt; jumped over the &lt;strong&gt;moon&lt;/strong&gt;.&lt;/p&gt; &lt;/body&gt;   Here we have a &lt;p&gt; paragraph element. Because it is a block-level element, this paragraph will fill its container (in this case the &lt;body&gt; element). It will also have empty space (margins) added above and below it.  Within this block, we also encounter a number of other inline elements. First, we have simple text. However, we also see the &lt;em&gt; and &lt;strong&gt; elements being used. These will affect their content, but not create a new block; rather, they will continue to flow inline in their container (the &lt;p&gt; element).  ","version":"Next","tagName":"h2"},{"title":"Content Sections (Block)​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#content-sections-block","content":" The following is a short list of some of the more commonly used &quot;block-level&quot; elements. Again, these are used to provide structure and meaning to the content:  &lt;h1&gt; - &lt;h6&gt; - renders six levels of section headings in &quot;bold&quot; text. &lt;h1&gt; is the highest section level (rendered by default as the largest header size) and &lt;h6&gt; is the lowest (rendered by default as the smallest header size). &lt;p&gt; - represents a paragraph. Paragraphs are usually represented in visual media as blocks of text separated from adjacent blocks by blank lines and/or first-line indentation, but HTML paragraphs can be any structural grouping of related content, such as images or form fields. &lt;div&gt; - serves as a &quot;generic&quot; container for content. Unlike the previous block level elements, it does not have any style applied to it (ie: no margins, font size changes, etc). &lt;header&gt;, &lt;nav&gt;, &lt;main&gt;, &lt;article&gt;, &lt;section&gt;, &lt;footer&gt; - these elements are similar to the above &lt;div&gt; element, however they describe the purpose of the element and the type of content it contains. These types of elements are known as &quot;Semantic Elements&quot;. For example, the &lt;nav&gt; element specifically indicates a section of a webpage that contains navigation links, guiding browsers and assistive technologies to treat this part differently from other content.  ","version":"Next","tagName":"h3"},{"title":"Text (Inline)​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#text-inline","content":" The following are some examples of common &quot;inline&quot; elements. Unlike &quot;block-level&quot; elements, these only occupy as much width on the page as required for their content (ie: they do not expand to fill the width of their parent element):  &lt;em&gt; - used to &quot;emphasize&quot; a section of text. By default, this will render the text using an italic font style. &lt;strong&gt; - this element is also used to emphasize a section of text, however in this case the text will be rendered using a bold font style. &lt;code&gt; - if your text contains a fragment of computer code (like the html snippets on this page), a common way to indicate this is with the &lt;code&gt; element. By default it will render the text using the client's default monospace font. &lt;span&gt; - like the &lt;div&gt; element, this serves as a &quot;generic&quot; container for content (it does not have any style applied to it). However, unlike &lt;div&gt;, it only occupies as much width as required for the content. &lt;a&gt; - this element, also known as the anchor element, is used to create hyperlinks, which are clickable links that navigate to other resources. These resources can be webpages, files, email addresses, or any URL. Common attributes include: href: Specifies the URL of the page the link goes to. This can be an absolute URL, a relative URL, or a local link. For local links within the same page, use the &quot;#&quot; symbol followed by the id of the target element. For example, href=&quot;#section1&quot; will link to an element with id=&quot;section1&quot; on the same page. target: Specifies where to open the linked document. For example, &quot;_blank&quot; opens the document in a new tab or window. rel: Specifies the relationship between the current document and the linked document. Common values include &quot;noopener&quot; and &quot;noreferrer&quot;. &lt;a href=&quot;https://www.google.ca/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer&quot;&gt;Visit Google.ca&lt;/a&gt;   ","version":"Next","tagName":"h3"},{"title":"Void (Empty) Elements​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#void-empty-elements","content":" Many of the elements we've seen so far begin with an opening tag, and end with a closing tag: &lt;body&gt;&lt;/body&gt;. However, not all elements need to be closed. Some elements have no content, and therefore don't need to have a closing tag. We call these void elements.  An example is the &lt;br&gt; line break element. We use a &lt;br&gt; when we want to tell the browser to insert a newline (similar to using \\n in C):  &lt;p&gt;Knock, Knock&lt;br /&gt;Who's there?&lt;/p&gt;   Other examples of void elements include &lt;hr&gt; (for a horizontal line), &lt;meta&gt; for including metadata in the &lt;head&gt;, and a dozen others.  ","version":"Next","tagName":"h2"},{"title":"Lists​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#lists","content":" In HTML, lists are used to organize content in a structured and easily readable format, similar to how lists are used in Microsoft Word. To achieve this, we use the following elements:  &lt;ol&gt; - the top level (&quot;root&quot;) element of the list - it is this element that contains the &quot;list items&quot;. &lt;ol&gt; signifies that this is an &quot;Ordered List&quot; and will render the containing &quot;list items&quot; using numbers. &lt;ul&gt; - this element functions exactly the same way as the above &lt;ol&gt; element, except that it indicates an &quot;Unordered List&quot;. This will cause the containing &quot;list items&quot; to render using bullet points by default instead of numbers  We define list items themselves using the following:  &lt;li&gt; - this is the element that is used within either an &quot;ordered&quot; or &quot;unordered&quot; list to indicate the elements of the list. Each element of the list will be contained within one &lt;li&gt; or &quot;list item&quot;.  The following is an example of an &quot;unordered&quot; list of items, contained within an &quot;ordered&quot; list (specifically the first item)  &lt;ol&gt; &lt;li&gt; First Item &lt;ul&gt; &lt;li&gt;Subitem 1&lt;/li&gt; &lt;li&gt;Subitem 2&lt;/li&gt; &lt;li&gt;Subitem 3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Second Item&lt;/li&gt; &lt;li&gt;Third Item&lt;/li&gt; &lt;/ol&gt;   ","version":"Next","tagName":"h2"},{"title":"Tables​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#tables","content":" Sometimes our data is tabular in nature, and we need to present it in a grid. A number of elements are used to create them:  &lt;table&gt; - the root of a table in HTML &lt;caption&gt; - the optional title (or caption) of the table &lt;thead&gt; - row(s) at the top of the table (header row or rows) &lt;tbody&gt; - rows that form the main body of the table (the table's content rows) &lt;tfoot&gt; - row(s) at the bottom of the table (footer row or rows)  We define rows and columns of data within the above using the following:  &lt;tr&gt; - a single row in a table &lt;td&gt; - a single cell (row/column intersection) that contains table data &lt;th&gt; - a header (e.g., a title for a column)  We can use the rowspan and colspan attributes to extend table elements beyond their usual bounds, for example: have an element span three columns (colspan=&quot;3&quot;) or have a heading span 3 rows (rowspan=&quot;3&quot;).  &lt;table&gt; &lt;caption&gt; Order Information &lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;Quantity&lt;/th&gt; &lt;th&gt;Colour&lt;/th&gt; &lt;th&gt;Price (CAD)&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th rowspan=&quot;3&quot;&gt;Products&lt;/th&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;Red&lt;/td&gt; &lt;td&gt;$5.60&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;Blue&lt;/td&gt; &lt;td&gt;$3.00&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;8&lt;/td&gt; &lt;td&gt;Blue&lt;/td&gt; &lt;td&gt;$1.50&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th colspan=&quot;3&quot;&gt;Total&lt;/th&gt; &lt;th&gt;$26.60&lt;/th&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt;   ","version":"Next","tagName":"h2"},{"title":"Multimedia​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#multimedia","content":" HTML5 provides built-in support for incorporating images, videos, and audio directly into pages, enhancing multimedia experiences. The following are examples of how to use three of the most commonly used elements: &lt;img&gt;, &lt;video&gt;, and &lt;audio&gt;.  ","version":"Next","tagName":"h2"},{"title":"Image​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#image","content":" To begin, we will discuss the &lt;img&gt; element - used for embedding images into the content of your page. The attributes available are:  src - this is required, and contains the path to the image you want to embed. alt - used to specify alternate text for an image - providing alternative information if the image cannot be displayed due to reasons such as slow internet connections, errors in the src attribute, or when the user relies on a screen reader. This attribute is crucial for accessibility, as it allows screen readers to convey the meaning of the image.  &lt;!-- External image URL, use full width of browser window --&gt; &lt;img src=&quot;https://images.unsplash.com/photo-1502720433255-614171a1835e?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=344dfca9dc8cb137a4b1c2c711752bc5&quot; alt=&quot;Toronto Sign (text)&quot; /&gt; &lt;!-- Local file cat.jpg, limit to 400 pixels wide --&gt; &lt;img src=&quot;cat.jpg&quot; alt=&quot;Picture of a cat&quot; width=&quot;400&quot; /&gt;   HTML5 has also recently added the &lt;picture&gt; element, to allow for an optimal image type to be chosen from amongst a list of several options.  ","version":"Next","tagName":"h3"},{"title":"Audio​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#audio","content":" Now that we have covered the &lt;img&gt; element, let's move on to another important multimedia element in HTML: the &lt;audio&gt; element. This element is used to embed sound content, such as music or audio clips, into your page.  Here are some of the key attributes available for the &lt;audio&gt; element:  src - this attribute specifies the path to the audio file you want to embed. Similar to the &lt;img&gt; element, the src attribute is required if you are not using nested &lt;source&gt; elements to define multiple audio formats. controls - by adding this attribute, you enable built-in controls for the audio player, such as play, pause, and volume. This attribute ensures that users can interact with the audio easily. autoplay - when this attribute is present, the audio will begin playing automatically as soon as it is ready. However, you should use this feature sparingly, as autoplaying audio can be intrusive / unpleasant for users. loop - this attribute causes the audio to restart from the beginning once it has finished playing, creating a continuous loop. muted - this attribute mutes the audio - useful if you want the audio to be initially silent. preload - This attribute provides a hint to the browser about whether the audio file should be preloaded. The possible values are &quot;auto&quot; (default), &quot;metadata&quot; (only preload metadata), and &quot;none&quot; (do not preload the audio).  &lt;!-- Audio with controls showing, only MP3 source provided --&gt; &lt;audio src=&quot;https://samplelib.com/lib/preview/mp3/sample-15s.mp3&quot; controls&gt;&lt;/audio&gt; &lt;!-- Audio with controls showing, multiple formats available --&gt; &lt;audio controls&gt; &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mp3&quot; /&gt; &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot; /&gt; &lt;p&gt; Sorry, your browser doesn't support HTML5 audio. Here is a &lt;a href=&quot;song.mp3&quot;&gt;link to the audio&lt;/a&gt; instead &lt;/p&gt; . &lt;/audio&gt;   ","version":"Next","tagName":"h3"},{"title":"Video​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#video","content":" Finally, let's discuss the &lt;video&gt; element. Similar to the &lt;audio&gt; element, this element allows us to embed media content directly into our pages, providing an integrated player for video content.  Key attributes of the &lt;video&gt; element include:  src - specifies the URL of the video file. Like the &lt;audio&gt; element, the src attribute is required if you are not using nested &lt;source&gt; elements to define multiple video formats. controls - when present, this attribute enables the default video controls such as play, pause, and volume. autoplay - if set, the video will start playing as soon as it is ready, without waiting for user interaction. loop - makes the video start over again, every time it is finished. muted - mutes the audio of the video. poster - specifies an image to be shown while the video is downloading or until the user hits the play button. width and height - define the dimensions of the video player.  &lt;!-- External Video File, MP4 file format, show controls --&gt; &lt;video src=&quot;http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4&quot; controls &gt;&lt;/video&gt; &lt;!-- Local video file in various formats, show with controls --&gt; &lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;video.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;source src=&quot;video.webm&quot; type=&quot;video/webm&quot; /&gt; &lt;p&gt;Sorry, your browser doesn't support HTML5 video&lt;/p&gt; &lt;/video&gt;   NOTE: the &lt;audio&gt; and &lt;video&gt; elements must use source URLs that point to actual audio or video files and not to a YouTube URL or some other source that is actually an HTML page.  ","version":"Next","tagName":"h3"},{"title":"Validating HTML​","type":1,"pageTitle":"HTML Elements","url":"/WebProgrammingFoundations/HTML5-Introduction/html-elements#validating-html","content":" It's clear that learning to write proper and correct HTML is going to take practice. There are lots of elements to get used to, and learn to use in conjunction. Also each has various attributes that have to be taken into account.  Browsers are fairly liberal in what they will accept in the way of HTML. Even if an HTML file isn't 100% perfect, a browser can often still render something. That said, it's best if we do our best to provide valid HTML.  In order to make sure that your HTML is valid, you can use an HTML Validator. There are a few available online:  https://html5.validator.nu/https://validator.w3.org/  Both allow you to enter a URL to an existing page, or enter HTML directly in a text field. They will then attempt to parse your HTML and report back on any errors or warnings, for example: an element missing a closing tag. ","version":"Next","tagName":"h2"},{"title":"Conditional Statements","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/conditional-statements","content":"","keywords":"","version":"Next"},{"title":"Basic Syntax​","type":1,"pageTitle":"Conditional Statements","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/conditional-statements#basic-syntax","content":" The most fundamental conditional statement in JavaScript is the if statement. It checks a condition and executes a block of code if the condition is true. The syntax for an if statement is as follows:  if (condition) { // code to execute if condition is true }   ","version":"Next","tagName":"h2"},{"title":"Example: Checking Balance​","type":1,"pageTitle":"Conditional Statements","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/conditional-statements#example-checking-balance","content":" Consider a scenario where you want to check if a user has enough balance to purchase an item. Here's how you could implement this using an if statement:  // Set balance and price of item let balance = 500; let itemPrice = 100; // Check if there are enough funds to purchase item if (itemPrice &lt;= balance) { console.log('You have enough money to purchase the item!'); } else { console.log('You do not have enough money in your account to purchase this item.'); }   In this example, the if statement checks if the price of the item is less than or equal to the user's balance. If the condition is true, it logs a success message; otherwise, it logs a failure message.  ","version":"Next","tagName":"h3"},{"title":"Else Statement​","type":1,"pageTitle":"Conditional Statements","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/conditional-statements#else-statement","content":" The else statement allows you to specify alternative code to run if the condition in the if statement is false. The syntax combines if and else as follows:  if (condition) { // code to execute if condition is true } else { // code to execute if condition is false }   ","version":"Next","tagName":"h3"},{"title":"Else If Statement​","type":1,"pageTitle":"Conditional Statements","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/conditional-statements#else-if-statement","content":" The else if statement in JavaScript allows you to check multiple conditions sequentially. It is used after an if statement and before an optional else statement. The else if statement checks whether a new condition is true. If it is, the code block associated with that condition is executed. If none of the conditions are true, the code block under the else statement (if present) is executed.  Basic Syntax  The basic syntax for using else if is as follows:  if (condition1) { // code to execute if condition1 is true } else if (condition2) { // code to execute if condition1 is false and condition2 is true } else { // code to execute if both condition1 and condition2 are false }   Example: Checking User Age​  Let's say you're building a website that displays content based on the user's age. Here's how you might use if, else if, and else to tailor the experience:  let userAge = 25; if (userAge &gt;= 18 &amp;&amp; userAge &lt; 30) { console.log(&quot;Welcome You're eligible for our special offer.&quot;); } else if (userAge &gt;= 30 &amp;&amp; userAge &lt; 40) { console.log('Hello Enjoy exploring our products.'); } else { console.log('Welcome We hope you enjoy browsing our site.'); }   In this example:  If the user is between 18 and 29 years old, they receive a special welcome message. If the user is between 30 and 39 years old, they get a general welcome message. If the user is younger than 18 or older than 39, they receive a generic welcome message.  Important Notes  There is no elseif syntax in JavaScript. Always use else if. Conditions are checked in order. Once a condition is found to be true, the corresponding block of code is executed, and the rest of the conditions are ignored. An else statement is optional and serves as a fallback if none of the if or else if conditions are met.  By using if, else if, and else, you can create complex logic flows in your JavaScript applications, enabling them to respond dynamically to various conditions.  ","version":"Next","tagName":"h3"},{"title":"Ternary Operator​","type":1,"pageTitle":"Conditional Statements","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/conditional-statements#ternary-operator","content":" For simple conditions with two outcomes, the ternary operator provides a concise way to write conditional expressions. Its syntax is:  condition? expressionTrue : expressionFalse;   Here's how you could rewrite the balance check using a ternary operator:  const message = itemPrice &lt;= balance ? 'You have enough money to purchase the item!' : 'You do not have enough money in your account to purchase this item.'; console.log(message);   This single line of code performs the same check as the previous example but uses the ternary operator for brevity. ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/example-code","content":"Example Code You may download the sample code for this topic here: JavaScript-Fundamentals","keywords":"","version":"Next"},{"title":"Hello World","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Introduction/hello-world","content":"","keywords":"","version":"Next"},{"title":"Introduction to JavaScript​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingFoundations/Introduction/hello-world#introduction-to-javascript","content":" As you may have guessed from above, the first web technology we will learn is JavaScript. JavaScript (often shortened to JS) is a lightweight, interpreted or JIT (i.e., Just In Time) compiled language meant to be embedded in host environments, for example, web browsers or runtime environments such as &quot;Node.js&quot;.  JavaScript looks similar to C/C++ or Java in some of its syntax, but is quite different in philosophy; it is more closely related to Scheme than C. For example, JavaScript is a dynamic scripting language supporting multiple programming styles, from object-oriented to imperative to functional.  JavaScript is one of, if not the most popular programming languages in the world, and has been for many years. Learning JavaScript well will be a tremendous asset to any software developer, since so much of the software we use is built using JS.  JavaScript's many versions: JavaScript is an evolving language, and you'll hear it referred to by a number of names, including: ECMAScript (or ES), ES5, ES6, ES2015, ES2017, ..., ES2021, ES2022, etc. ECMA is the European Computer Manufacturers Association, which is the standards body responsible for the JS language. As the standard evolves, the specification goes through different versions, adding or changing features and syntax. In this course we will primarily focus on ECMAScript 6 (ES6) and newer versions, which all browsers support. We will also sometimes use new features of the language, which most browsers support. Language feature support across browsers is maintained in this table.  ","version":"Next","tagName":"h2"},{"title":"JavaScript Resources​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingFoundations/Introduction/hello-world#javascript-resources","content":" Throughout the coming weeks, we'll make use of a number of important online resources. They are listed here so you can make yourself aware of them, and begin to explore on your own. All programmers, no matter how experienced, have to return to these documents on a routine basis, so it's good to know about them.  JavaScript on MDN JavaScript GuideJavaScript Reference Eloquent JavaScriptJavaScript for impatient programmers (ES2022 edition)  ","version":"Next","tagName":"h3"},{"title":"JavaScript Environments​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingFoundations/Introduction/hello-world#javascript-environments","content":" JavaScript is meant to be run within a host environment. There are many possible environments, but we will focus on the following:  Web Browsers, and their associated developer tools, primarily: Chrome DevToolsFirefox Developer Tools Node.js, and its command line REPL (Read-Eval-Print-Loop)  If you haven't done so already, you should install all of the above.  JavaScript Engines​  JavaScript is parsed, executed, and managed (i.e., memory, garbage collection, etc) by an engine written in C/C++. There are a number of JavaScript engines available, the most common of which are:  V8, maintained an used by Google in Chrome and in node.jsSpiderMonkey, maintained and used by Mozilla in FirefoxChakraCore, maintained and used by Microsoft in EdgeJavaScriptCore, maintained and used by Apple in Safari  These engines, much like car engines, are meant to be used within a larger context. We will encounter them indirectly via web browsers and in node.js.  It's not important to understand a lot about each of these engines at this point, other than to be aware that each has its own implementation of the ECMAScript standards, its own performance characteristics (i.e., some are faster at certain things), as well as its own set of bugs.  ","version":"Next","tagName":"h3"},{"title":"JavaScript Syntax​","type":1,"pageTitle":"Hello World","url":"/WebProgrammingFoundations/Introduction/hello-world#javascript-syntax","content":" Recommend Readings​  We will spend the next few weeks learning JavaScript, and there is no one best way to do it. The more you read and experiment the better. The following chapters/pages give a good overview:  Chapter 1. Basic JavaScript of Exploring JS (ES5).MDN JavaScript Introduction TutorialChapter 1. Values, Types and Operators and Chapter 2. Program Structure of Eloquent JavaScript (2nd Ed.).  Important Ideas​  JavaScript is Case-Sensitive: customerCount is not the same thing as CustomerCount or customercount Name things using camelCase (first letter lowercase, subsequent words start with uppercase) vs. snake_case. Semicolons are optional in JavaScript, but highly recommended. We'll expect you to use them in this course, and using them will make working in C++, Java, CSS, etc. much easier, since you have to use them there. Comments work like C/C++, and can be single or multi-line // This is a single line comment. NOTE: the space between the // and first letter. /* This is a multi-line comment, and can be as long as you need. */ Whitespace: JavaScript will mostly ignore whitespace (spaces, tabs, newlines). In this course we will expect you to use good indentation practices, and for your code to be clean and readable. Many web programmers use Prettier to automatically format their code, and we will too: // This is poorly indented, and needs more whitespace function add(a, b) { if (!b) { return a; } else { return a + b; } } // This is much more readable due to the use of whitespace function add(a, b) { if (!b) { return a; } else { return a + b; } } JavaScript statements: a JavaScript program typically consists of a series of statements. A statement is a single-line of instruction made up of objects, expressions, variables, and events/event handlers. Block statement: a block statement, or compound statement, is a group of statements that are treated as a single entity and are grouped within curly brackets {...}. Opening and closing braces need to work in pairs. For example, if you use the left brace { to indicate the start of a block, then you must use the right brace } to end it. The same matching pairs applies to single '......' and double &quot;.......&quot; quotes to designate text strings.  Variables​  Variables are declared using the let keyword. You must use the let keyword to precede a variable name, but you do not need to provide a type, since the initial value will set the type.  let year; let seasonName = 'Fall'; // Referring to and using syntax: year = 2023; console.log(seasonName, year);   NOTE: JavaScript also supports the var and const keywords for variable declaration.  Variables must start with a letter (a-zA-Z), underscore (_), or dollar sign ($). They cannot be a reserved (key) word. Subsequent characters can be letters, numbers, underscores. If you forget to use the let keyword, JavaScript will still allow you to use a variable, and simply create a global variable. We often refer to this as &quot;leaking a global,&quot; and it should always be avoided:  let a = 6; // GOOD: a is declared with let b = 7; // BAD: b is used without declaration, and is now a global   Data Types​  JavaScript is a typeless language -- you don't need to specify a type for your data (it will be inferred at runtime). However, internally, the following data types are used:  Number - a double-precision 64-bit floating point number. Using Number you can work with both Integers and Floats. There are also some special Number types, Infinity and NaN. BigInt - a value that can be too large to be represented by a Number (larger than Number. MAX_SAFE_INTEGER,) can be represented by a BigInt. This can easily be done by appending n to the end of an integer value. String - a sequence of Unicode characters. JavaScript supports both single ('...') and double (&quot;...&quot;) quotes when defining a String. NOTE: JavaScript doesn't distinguish between a single char and a multi-character String -- everything is a String. You define a String using either single ('...'), double (&quot;...&quot;) quotes. Try to pick one style and stick with it within a given file/program vs. mixing them. Modern ECMAScript also allows for the use of template literals. Instead of ' or &quot;, a template literal uses ` (backticks), and you can also interpolate expressions. Boolean - a value of true or false. We'll also see how JavaScript supports so-called truthy and falsy values that are not pure Booleans. Object, which includes Function, Array, Date, and many more. - JavaScript supports object-oriented programming, and uses objects and functions as first-class members of the language. Symbol - a primitive type in JavaScript that represents a unique and anonymous value/identifier. They can normally be used as an object's unique properties. null - a value that means &quot;this is intentionally nothing&quot; vs. undefined undefined - a special value that indicates a value has never been defined.  Declaration\tType\tValuelet s1 = &quot;some text&quot;;\tString\t&quot;some text&quot; let s2 = 'some text';\tString\t&quot;some text&quot; let s3 = '172';\tString\t&quot;172&quot; let s4 = '172' + 4;\tString\t&quot;1724&quot; (concatenation vs. addition) let n1 = 172;\tNumber\t172 (integer) let n2 = 172.45;\tNumber\t172.45 (double-precision float) let n3 = 9007199254740993n;\tBigInt\t9007199254740993n (integer) let b1 = true;\tBoolean\ttrue let b2 = false;\tBoolean\tfalse let b3 = !b2;\tBoolean\ttrue let s = Symbol(&quot;Sym&quot;);\tsymbol\tSymbol(Sym) let c;\tundefined\tundefined let d = null;\tobject\tnull  Arrays​  We can create an Array in JavaScript using an &quot;Array literal&quot;, using the following syntax (we will discuss the &quot;Array Object&quot; further in the coming weeks):  let arr2 = [1, 2, 3]; // array literal   Like arrays in C / C++, a JavaScript Array has a length, and items contained within it can be accessed via an index:  let arr = [1, 2, 3]; let len = arr.length; // len is 3 let item0 = arr[0]; // item0 is 1   Unlike languages such as C / C++ , a JavaScript Array can contain any type of data, including mixed types:  let list = [0, '1', 'two', true];   JavaScript Arrays can also contain holes (i.e., be missing certain elements), change size dynamically at runtime, and we don't need to specify an initial size:  let arr = []; // empty array arr[5] = 56; // element 5 now contains 56, and arr's length is now 6   NOTE: a JavaScript Array is really a map, which is a data structure that associates values with unique keys (often called a key-value pair). JavaScript arrays are a special kind of map that uses numbers for the keys, which makes them look and behave very much like arrays in other languages. We will encounter this map structure again when we look at how to create Objects.  Operators​  Common JavaScript Operators (there are more, but these are a good start):  Operator\tOperation\tExample+\tAddition of Numbers\t3 + 4 +\tConcatenation of Strings\t&quot;Hello &quot; + &quot;World&quot; -\tSubtraction of Numbers\tx - y *\tMultiplication of Numbers\t3 * n /\tDivision of Numbers\t2 / 4 %\tModulo\t7 % 3 (gives 1 remainder) ++\tPost/Pre Increment\tx++, ++x --\tPost/Pre Decrement\tx--, --x =\tAssignment\ta = 6 +=\tAssignment with addition\ta += 7 same as a = a + 7. Can be used to join Strings too -=\tAssignment with subtraction\ta -= 7 same as a = a - 7 *=\tAssignment with multiplication\ta *= 7 same as a = a * 7 /=\tAssignment with division\ta /= 7 same as a = a / 7 &amp;&amp;\tLogical AND\tif(x &gt; 3 &amp;&amp; x &lt; 10) both must be true ()\tCall/Create\t() invokes a function, f() means invoke/call function stored in variable f ||\tLogical OR\tif(x === 3 || x === 10) only one must be true |\tBitwise OR\t3.1345|0 gives 3 as an integer !\tLogical NOT\tif(!(x === 2)) negates an expression ==\tEqual\t1 == 1 but also 1 == &quot;1&quot; due to type coercion ===\tStrict Equal\t1 === 1 but 1 === &quot;1&quot; is not true due to types. Prefer === !=\tNot Equal\t1 != 2, with type coercion !==\tStrict Not Equal\t1 !== &quot;1&quot;. Prefer !== &gt;\tGreater Than\t7 &gt; 3 &gt;=\tGreater Than Or Equal\t7 &gt;=7 and 7 &gt;= 3 &lt;\tLess Than\t3 &lt; 10 &lt;=\tLess Than Or Equal\t3 &lt; 10 and 3 &lt;=3 typeof\tType Of\ttypeof &quot;Hello&quot; gives 'string', typeof 6 gives 'number' cond ? a : b\tTernary\tstatus = (age &gt;= 18) ? 'adult' : 'minor';  NOTE: JavaScript is dynamic, and variables can change value and type at runtime: let a; // undefined a = 6; // 6, Number a++; // 7, Number a--; // 6, Number a += 3; // 9, Number a = 'Value=' + a; // &quot;Value=9&quot;, String a = !!a; // true, Boolean a = null; // null   JavaScript is also a garbage collected language. Memory automatically gets freed at runtime when variables are not longer in scope or reachable. We still need to be careful not to leak memory (i.e., hold onto data longer than necessary, or forever) and block the garbage collector from doing its job.  Expressions​  A JavaScript expression is any code (e.g., literals, variables, operators, and expressions) that evaluates to a single value. The value may be a Number, String, an Object, or a logical value.  let a = 10 / 2; // arithmetic expression let b = !(10 / 2); // logical expression evaluates to false let c = '10 ' + '/' + ' 2'; // string, evaluates to &quot;10 / 2&quot;  ","version":"Next","tagName":"h3"},{"title":"Iteration","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/iteration","content":"","keywords":"","version":"Next"},{"title":"For Loop​","type":1,"pageTitle":"Iteration","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/iteration#for-loop","content":" One of the most common iteration structures is the &quot;for&quot; statement:  for (initialization; condition; afterthought) statement   For example:  for (let i = 0; i &lt; 10; i++) { console.log(i); }   This code iterates through a sequence of numbers from 0 to 9, printing each number to the console. Here's a step-by-step explanation of how it works:  Initialization (let i = 0): The loop starts by declaring a variable i and initializing it to 0. This variable acts as the loop counter, which keeps track of the current iteration. Condition (i &lt; 10): Before each iteration of the loop, the condition i &lt; 10 is evaluated. If the condition is true, the loop body (the code inside the loop) is executed. If the condition is false, the loop stops executing. Iteration (i++): After the loop body is executed, the i++ expression increments the value of i by 1. This is known as the iteration statement, which prepares for the next loop cycle. Loop Body (console.log(i)): Inside the loop, the console.log(i) statement is executed, printing the current value of i to the console.  Putting it all together, the loop starts with i equal to 0 and continues to execute the loop body (printing the value of i) and incrementing i by 1 on each iteration until i is no longer less than 10. The output will be the numbers 0 through 9, each on a new line.  Here's what happens in each iteration:  1st iteration: i is 0, console.log(i) prints 0, i becomes 1.2nd iteration: i is 1, console.log(i) prints 1, i becomes 2.3rd iteration: i is 2, console.log(i) prints 2, i becomes 3....10th iteration: i is 9, console.log(i) prints 9, i becomes 10.  After the 10th iteration, i becomes 10, which makes the condition i &lt; 10 false, so the loop terminates.  ","version":"Next","tagName":"h2"},{"title":"Do While Loop​","type":1,"pageTitle":"Iteration","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/iteration#do-while-loop","content":" Another form of iteration is the &quot;do...while&quot; statement:  do statement while (condition);   For example:  let i = 0; do { console.log(i); i++; } while (i &lt; 10);   This code once again iterates through a sequence of numbers from 0 to 9, printing each number to the console. Here's a step-by-step explanation of how it works:  Initialization (let i = 0): The loop starts by declaring a variable i and initializing it to 0. This variable acts as the loop counter, which keeps track of the current iteration. Loop Body (console.log(i); i++): Inside the do block, the console.log(i) statement is executed, printing the current value of i to the console. Then, the i++ statement increments the value of i by 1. Condition (i &lt; 10): After executing the loop body, the condition i &lt; 10 is evaluated. If the condition is true, the loop repeats and executes the body again. If the condition is false, the loop terminates.  Unlike a for loop, a do...while loop ensures that the loop body is executed at least once, even if the condition is false initially.  Putting it all together, the loop starts with i equal to 0 and continues to execute the loop body (printing the value of i and incrementing i by 1) until i is no longer less than 10. The output will be the numbers 0 through 9, each on a new line.  Here's what happens in each iteration:  1st iteration: i is 0, console.log(i) prints 0, i becomes 1.2nd iteration: i is 1, console.log(i) prints 1, i becomes 2.3rd iteration: i is 2, console.log(i) prints 2, i becomes 3....10th iteration: i is 9, console.log(i) prints 9, i becomes 10.  After the 10th iteration, i becomes 10, which makes the condition i &lt; 10 false, so the loop terminates.  ","version":"Next","tagName":"h2"},{"title":"While Loop​","type":1,"pageTitle":"Iteration","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/iteration#while-loop","content":" Finally, let's quickly discuss the &quot;while&quot; statement:  while (condition) statement   For example:  let i = 0; while (i &lt; 10) { console.log(i); i++; }   You will notice that this is very similar to the do...while loop, however the primary distinction lies in the condition check. In a while loop, the condition is evaluated before executing the block of code inside the loop. This means that if the condition evaluates to false at the start, the loop body will never execute. Conversely, a do...while loop guarantees that the loop body will execute at least once because the condition is checked after the execution of the loop body. ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Objects-in-JavaScript/example-code","content":"Example Code You may download the sample code for this topic here: Objects-In-JavaScript","keywords":"","version":"Next"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Relational-Database-Postgres/example-code","content":"Example Code You may download the sample code for this topic here: Relational-Database-Postgres","keywords":"","version":"Next"},{"title":"Introduction to Postgres","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Relational-Database-Postgres/introduction-to-postgres","content":"","keywords":"","version":"Next"},{"title":"PostgreSQL (Postgres)​","type":1,"pageTitle":"Introduction to Postgres","url":"/WebProgrammingFoundations/Relational-Database-Postgres/introduction-to-postgres#postgresql-postgres","content":" From the PostgreSQL site, postgresql.org:  &quot;PostgreSQL (also known as &quot;Postgres&quot;) is a powerful, open source object-relational database system. It has more than 15 years of active development and a proven architecture that has earned it a strong reputation for reliability, data integrity, and correctness. It runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, macOS, Solaris, Tru64), and Windows. It is fully ACID compliant, has full support for foreign keys, joins, views, triggers, and stored procedures (in multiple languages). It includes most SQL:2008 data types, including INTEGER, NUMERIC, BOOLEAN, CHAR, VARCHAR, DATE, INTERVAL, and TIMESTAMP. It also supports storage of binary large objects, including pictures, sounds, or video. It has native programming interfaces for C/C++, Java, .Net, Perl, Python, Ruby, Tcl, ODBC, among others, and exceptional documentation.  This is a great choice for us for multiple reasons; it is open source, highly available, standards compliant and most importantly, works nicely with node.js.  To get started, proceed to https://neon.tech and click on the &quot;Log in&quot; link at the top and log in with your GitHub account. Once you're logged in, follow the below steps to set up the database:  in the &quot;Get started with Neon for Free&quot; page, enter a value for project Name, ie: Seneca and Database Name, ie: SenecaDB (We can add more databases later) Leave &quot;region&quot; as the default value and Click the Create Project Button. At the next screen, you should see a dropdown with &quot;Connection String&quot; selected. Click this and choose Parameters only. Next, click the eye icon to reveal your password (NOTE Also consider checking the &quot;Pooled connection&quot; checkbox if this app will be deployed in a serverless environment, such as Vercel) Copy the PGHOST, PGDATABASE, PGUSER and PGPASSWORD values  ","version":"Next","tagName":"h2"},{"title":"pgAdmin​","type":1,"pageTitle":"Introduction to Postgres","url":"/WebProgrammingFoundations/Relational-Database-Postgres/introduction-to-postgres#pgadmin","content":" Now that we have our brand new Postgres database created in Neon.tech, why don't we try to connect to it using the most popular GUI tool for Postgres; pgAdmin. If you're following along from the lab room, it should already be installed. However, if you're configuring your home machine, you will need to download pgAdmin:  https://www.pgadmin.org/download/  Once it is installed and you have opened the app, we need to configure it to connect to our database:  Right Click on the &quot;Servers&quot; icon in the left pane (Under &quot;Browser&quot;) and select Create &gt; Server This will open the &quot;Create - Server&quot; Dialog window. Proceed to enter the following information about your Postgres Database on Neon.tech. Field\tValueName\tThis can be anything you like, ie &quot;Test Connection&quot; (Connection Tab) Host\tThis is the server for your Neon.tech Postgres DB (&quot;PGHOST&quot; value), ie: ab-cd-12345.us-east-2.aws.neon.tech (Connection Tab) Port\tThis is the port for your Neon.tech Postgres DB - it should be the same as what's already there, ie: 5432 (Connection Tab) Maintenance database\tEnter your &quot;PGDATABASE&quot; value here (Connection Tab) Username\tEnter your &quot;PGUSER&quot; value here (Connection Tab) Password\tEnter your &quot;PGPASSWORD&quot; value here Once you have entered all of your information, hit the &quot;Save&quot; button and click &quot;Servers&quot; in the left pane to expand your server connections. If you entered valid information for the above fields, you should see your Neon.tech Postgres DB Connection. Expand this item and the following &quot;Databases (2)&quot; item, and you should see your database. Expand this item, as well as the nested &quot;Schemas (1)&quot; item, followed by the &quot;public&quot; item, and you should be presented with something that looks like this:  Success! We will be keeping an eye on our data using this tool, so it is wise to have it running during development. ","version":"Next","tagName":"h2"},{"title":"Custom Objects","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Objects-in-JavaScript/custom-objects","content":"","keywords":"","version":"Next"},{"title":"Object Literal Notation​","type":1,"pageTitle":"Custom Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/custom-objects#object-literal-notation","content":" The most simple and straight-forward way to create an object in JavaScript is to use &quot;Object Literal Notation&quot; (sometimes referred to as &quot;object initializer&quot; notation). The syntax for creating an object using this notation is as follows:  let obj = { property_1: value_1, property_2: value_2, // ..., 'property n': value_n, }; // properties can also be defined as a string`   So, if we wanted to create an object with the following properties:  name (string)age (number)occupation (string)  and methods...  setName (&quot;setter&quot; to set a new value for the &quot;name&quot; property)setAge (&quot;setter&quot; to set a new value for the &quot;age&quot; property)getName (&quot;getter&quot; to get the current value of the &quot;name&quot; property)getAge (&quot;getter&quot; to get the current value of the &quot;age&quot; property)  using &quot;Object Literal&quot; notation, we would write the code:  let architect = { name: 'Joe', age: 34, occupation: 'Architect', setName: function (newName) { this.name = newName; }, setAge: function (newAge) { this.age = newAge; }, getName: function () { return this.name; }, getAge: function () { return this.age; }, };   and access the data (properties) and functions (methods) using the following code, ie:  console.log(architect.name); // &quot;Joe&quot; // or console.log(architect.getName()); // &quot;Joe&quot;   We must use the “this” keyword whenever we refer to one of the properties of the object inside one of it’s methods. This is due to the fact that when a method is executed, &quot;age&quot; (for example) might already exist in the global scope, or within the scope of the function as a local variable. To be absolutely sure that we are referring to the correct &quot;age&quot; property of the current object, we must refer to the &quot;execution context&quot; - ie: the object that is actually making a call to this method. We know the object has an &quot;age&quot; property, so in order to be more specific about which age variable that we want to change, we leverage the keyword this. &quot;this&quot; will refer to the &quot;execution context&quot;, ie: the object that called the function! So, &quot;this.age&quot; can be read literally as &quot;the age property on this object&quot;, which is exactly the property that we wish to edit.  However, while &quot;this&quot; allows us to be specific with which properties that we refer to in our methods, it can lead to some confusing scenarios. For example, what if we added a new &quot;outputNameDelay()&quot; method to our architect object that writes the architect's name to the console after 1 second (1000 milliseconds):  // ... outputNameDelay: function(){ setTimeout(function(){ console.log(this.name); },1000); } // ... architect.outputNameDelay(); // outputs undefined   Everything looks correct and we have made proper use of the &quot;this&quot;, however because the setTimeout function is not executed as a method of our architect object, we end up with &quot;undefined&quot; as output to the console. There are a number of fixes for this issue, however the most common is by using an &quot;arrow function&quot; as we have seen when first discussing JavaScript. The reason that this works is because Arrow functions use a &quot;lexical&quot; this (ie: the &quot;this&quot; value of the parent scope).  // ... outputNameDelay: function(){ setTimeout(() =&gt; { console.log(this.name); },1000); } // ... architect.outputNameDelay(); // outputs &quot;Joe&quot;   ","version":"Next","tagName":"h2"},{"title":"The \"class\" keyword​","type":1,"pageTitle":"Custom Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/custom-objects#the-class-keyword","content":" If we wish to create multiple objects of the same &quot;type&quot; (ie: that have the same properties and methods, but with different values), we can leverage the &quot;class&quot; and &quot;new&quot; keywords, ie:  class Architect { name; age; occupation = 'architect'; // default value of &quot;architect&quot; for occupation constructor(setName = '', setAge = 0) { // handle missing parameters with '' and 0 this.name = setName; this.age = setAge; } setName(newName) { this.name = newName; } setAge(newAge) { this.age = newAge; } getName() { return this.name; } getAge() { return this.age; } } // define new &quot;architect objects using the &quot;new&quot; keyword with the &quot;architect&quot; class let architect1 = new Architect('Joe', 34); let architect2 = new Architect('Mary', 49); // samples of accessing properties and methods on both objects console.log(architect1.name); // &quot;Joe&quot; console.log(architect1.getName()); // &quot;Joe&quot; console.log(architect2.getName()); // &quot;Mary&quot;   Here, we specify the properties (with default values), a &quot;constructor&quot; function to take initialization parameters, as well as specify all of the methods within the &quot;class&quot; block.  NOTE: For more information / advanced topics on objects in JavaScript, such as: &quot;Private Methods / Properties&quot;, &quot;Getters / Setters&quot; and &quot;Inheritance&quot; see the documentation on MDN. ","version":"Next","tagName":"h2"},{"title":"Functions","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions","content":"","keywords":"","version":"Next"},{"title":"User-defined Functions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#user-defined-functions","content":" JavaScript has many built-in functions, which we'll get to later on in these notes; however, it also allows you to write your own and/or use functions written by other developers (libraries, frameworks).  These user-defined functions can take a number of forms.  ","version":"Next","tagName":"h2"},{"title":"Function Declarations​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#function-declarations","content":" The first is the function declaration, which looks like this:  // The most basic function, a so-called NO OPERATION function function noop() {} // square function accepts one parameter `n`, returns its value squared. function square(n) { return n * n; } // add function accepts two parameters, `a` and `b`, returns their sum. function add(a, b) { return a + b; }   Here the function keyword initiates a function declaration, followed by aname, a parameter list in round parenthesis, and the function's body surrounded by curly braces. There is no semi-colon after the function body.  ","version":"Next","tagName":"h3"},{"title":"Function Expressions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#function-expressions","content":" The second way to create a function is using a function expression. Recall that expressions evaluate to a value: a function expression evaluates to a function Object. The resulting value is often bound (i.e., assigned) to a variable, or used as a parameter.  let noop = function () {}; let square = function (n) { return n * n; }; let add = function add(a, b) { return a + b; };   A few things to note:  The function's name is often omitted. Instead we return an anonymous function and bind it to a variable. We'll access it again via the variable name. In the case of recursive functions, we sometimes include it to make it easier for functions to call themselves. You'll see it done both ways. We did use a semi-colon at the end of our function expression. We do this to signify the end of our assignment statement let add = ... ;. In general, function declarations are likely a better choice (when you can choose) due to subtle errors introduced with declaration order and hoisting; however, both are used widely and are useful.  ","version":"Next","tagName":"h3"},{"title":"Arrow Functions​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#arrow-functions","content":" Modern JavaScript also introduces a new function syntax called an Arrow Function or &quot;Fat Arrow&quot;. These functions are more terse, using the =&gt; notation (not to be confused with the &lt;= and &gt;= comparison operators):  let noop = () =&gt; {}; let square = (n) =&gt; n * n; let add = (a, b) =&gt; a + b;   When you see let add = (a, b) =&gt; a + b; it is short-hand for let add = function(a, b) { return a + b; }, where =&gt; replaces the function keyword and comes after the parameter list, and the return keyword is optional, when functions return a single value.  Arrow functions also introduce some new semantics for the this keyword, which we'll address later.  You should be aware of Arrow functions, since many web developers use them heavily. However, don't feel pressure to use them yet if you find their syntax confusing.  ","version":"Next","tagName":"h3"},{"title":"Parameters and arguments​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#parameters-and-arguments","content":" Function definitions in both cases take parameter lists, which can be empty, single, or multiple in length. Just as with variable declaration, no type information is given:  function emptyParamList() {} function singleParam(oneParameter) {} function multipleParams(one, two, three, four) {}   A function can accept any number of arguments when it is called, including none. This would break in many other languages, but not JavaScript:  function log(a) { console.log(a); } log('correct'); // logs &quot;correct&quot; log('also', 'correct'); // logs &quot;also&quot; log(); // logs undefined   Because we can invoke a function with any number of arguments, we have to write our functions carefully, and test things before we make assumptions. How can we deal with a caller sending 2 vs. 10 values to our function?  One way we do this is using the built-in arguments Object.  Every function has an implicit arguments variable available to it, which is an array-like object containing all the arguments passed to the function. We can use arguments.length to obtain the actual number of arguments passed to the function at runtime, and use array index notation (e.g., arguments[0]) to access an argument:  function log(a) { console.log(arguments.length, a, arguments[0]); } log('correct'); // 1, &quot;correct&quot;, &quot;correct&quot; log('also', 'correct'); // 2, &quot;also&quot;, &quot;also&quot; log(); // 0, undefined, undefined   We can use a loop to access all arguments, no matter the number passed:  function sum() { const count = arguments.length; let total = 0; for (let i = 0; i &lt; count; i++) { total += arguments[i]; } return total; } sum(1); // 1 sum(1, 2); // 3 sum(1, 2, 3, 4); // 10   You may have wondered previously how console.log() can work with one, two, three, or more arguments. The answer is that all JavaScript functions work this way, and you can use it to &quot;overload&quot; your functions with different argument patterns, making them useful in more than one scenario.  ","version":"Next","tagName":"h3"},{"title":"Parameters and \"...\"​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#parameters-and-","content":" Modern JavaScript also supports naming the &quot;rest&quot; of the parameters passed to a function. These Rest Parameters allow us to specify that all final arguments to a function, no matter how many, should be available to the function as a named Array.  There are some advantages to not using the implicit arguments keyword, which rest parameters provide.  We can convert the example above to this, naming our arbitrary list of &quot;numbers&quot;:  function sum(...numbers) { let total = 0; for (let i = 0; i &lt; numbers.length; i++) { total += numbers[i]; } return total; }   ","version":"Next","tagName":"h3"},{"title":"Dealing with Optional and Missing Arguments​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#dealing-with-optional-and-missing-arguments","content":" Because we can change the number of arguments we pass to a function at runtime, we also have to deal with missing data, or optional parameters. Consider the case of a function to calculate a player's score in a video game. In some cases we may wish to provide an optional bonus to the score, for example:  function updateScore(currentScore, value, bonus) { return bonus ? currentScore + value * bonus : currentScore + value; } updateScore(10, 3); updateScore(10, 3, 2);   Here we call updateScore first with 2 arguments, and then once with 3. Our updateScore function has been written so it will work in both cases. We've used a conditional ternary operator to decide whether or not to add an extra bonus score. When we say bonus ? ... : ... we are checking to see if the bonus argument is truthy or falsy--that is, did the caller provide a value for it? If they did, we do one thing, if not, we do another.  Here's another common way you'll see code like this written, using a default value:  function updateScore(currentScore, value, bonus) { // See if `bonus` is truthy (has a value or is undefined) and use it, or default to 1 bonus = bonus || 1; return currentScore + value * bonus; }   In this case, before we use the value of bonus, we do an extra check to see if it actually has a value or not. If it does, we use that value as is; but if it doesn't, we instead assign it a value of 1. Then, our calculation will always work, since multiplying the value by 1 will be the same as not using a bonus.  The idiom bonus = bonus || 1 is very common in JavaScript. It uses theLogical Or Operator || to test whether bonus evaluates to a value or not, and prefers that value if possible to the fallback default of 1. We could also have written it out using an if statements like these:  function updateScore(currentScore, value, bonus) { if (bonus) { return currentScore + value * bonus; } return currentScore + value; } function updateScore(currentScore, value, bonus) { if (!bonus) { bonus = 1; } return currentScore + value * bonus; }   JavaScript programmers tend to use the bonus = bonus || 1 pattern because it is less repetitive, using less code, and therefore less likely to introduce bugs. We could shorten it even further to this:  function updateScore(currentScore, value, bonus) { return currentScore + value * (bonus || 1); }   Because this pattern is so common, modern JavaScript has added a built-in way to handle Default Parameters. Instead of using || notation in the body of the function, we can specify a default value for any named parameter when it is declared. This frees us from having to check for, and set default values in the function body. Using default parameters, we could convert our code above to this:  function updateScore(currentScore, value, bonus = 1) { return currentScore + value * bonus; }   Now, if bonus has a value (i.e., is passed as a parameter), we use it; otherwise, we use 1 as a default.  ","version":"Next","tagName":"h3"},{"title":"Return Value​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#return-value","content":" Functions always return a value, whether implicitly or explicitly. If the returnkeyword is used, the expression following it is returned from the function. If it is omitted, the function will return undefined:  function implicitReturnUndefined() { // no return keyword, the function will return `undefined` anyway } function explicitReturnUndefined() { return; // return keyword, but no expression given, which is also `undefined` } function explicitReturn() { return 1; // return keyword, followed by `Number` expression evalutes to `Number` } function explicitReturn2() { return 'Hello' + ' World!'; // return keyword, followed by expression evaluating to a `String` }   ","version":"Next","tagName":"h3"},{"title":"Function Naming​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#function-naming","content":" Functions are typically named using the same rules we learned for naming any variable: camelCase and using the set of valid letters, numbers, etc. and avoiding language keywords.  Function declarations always give a name to the function, while function expressions often omit it, using a variable name instead:  // Name goes after the `function` keyword in a declaration function validateUser() { ... } // Name is used only at the level of the bound variable, function is anonymous let validateUser = function() { ... }; // Name is repeated, which is correct but not common. Used with recursive functions let validateUser = function validateUser() { ... }; // Names are different, which is also correct, but not common as it can lead to confusion let validateUser = function validate() { // the validate name is only accessible here, within the function body ... };   Because JavaScript allows us to bind function objects (i.e., result of function expressions) to variables, it is common to create functions without names, but immediately pass them to functions as arguments. The only way to use this function is via the argument name:  // The parameter `fn` will be a function, and `n` a number function execute(fn, n) { // Call the function referred to by the argument (i.e, variable) `fn`, passing `n` as its argument return fn(n); } // 1. Call the `execute` function, passing an anonymous function, which squares its argument, and the value 3 execute(function (n) { return n * n; }, 3); // 2. Same thing as above, but with different formatting execute(function (n) { return n * n; }, 3); // 3. Same thing as above, using an Arrow Function execute((n) =&gt; n * n, 3); let doubleIt = function (num) { return num * 2; }; // 4. Again call `execute`, but this time pass `doubleIt` as the function argument execute(doubleIt, 3);   We can also use functions declared via function declarations used this way, and bind them to variables:  function greeting(greeting, name) { return greeting + ' ' + name; } var sayHi = greeting; // also bind a reference to greeting to sayHi // We can now call `greeting` either with `greeting()` or `sayHi()` console.log(greeting('Hello', 'Steven')); console.log(sayHi('Hi', 'Kim'));   JavaScript treats functions like other languages treat numbers or booleans, and lets you use them as values. This is a very powerful feature, but can cause some confusion as you get started with JavaScript.  You might ask why we would ever choose to define functions using variables. One common reason is to swap function implementations at runtime, depending on the state of the program. Consider the following code for displaying the user interface depending on whether the user is logged in or not:  // Display partial UI for guests and non-authenticated users, hiding some features function showUnauthenticatedUI() { ... } // Display full UI for authenticated users function showAuthenticatedUI() { ... } // We will never call showUnauthenticatedUI or showAuthenticatedUI directly. // Instead, we will use showUI to hold a reference to one or the other, // and default to the unauthenticated version at first (i.e., until the user logs in). let showUI = showUnauthenticatedUI; ... // Later in the program, when a user logs in, we can swap the implementation // without touching any of our UI code. function authenticate(user) { ... showUI = showAuthenticatedUI; } ... // Whenever we need to refresh/display the UI, we can always safely call // whichever function is currently bound to `showUI`. showUI();   ","version":"Next","tagName":"h3"},{"title":"Invoking Functions, the Execution Operator​","type":1,"pageTitle":"Functions","url":"/WebProgrammingFoundations/JavaScript-Fundamentals/functions#invoking-functions-the-execution-operator","content":" In many of the examples above, we've been invoking (i.e., calling, running, executing) functions but haven't said much about it. We invoke a function by using the () operator:  let f = function () { console.log('f was invoked'); }; f();   In the code above, f is a variable that is assigned the value returned by a function expression. This means f is a regular variable, and we can use it like any other variable. For example, we could create another variable and share its value:  let f = function () { console.log('f was invoked'); }; let f2 = f; f(); // invokes the function f2(); // also invokes the function   Both f and f2 refer to the the same function object. What is the difference between saying f vs. f() in the line let f2 = f;? When we write f()we are really saying, &quot;Get the value of f (the function referred to) and invoke it.&quot; However, when we write f (without ()), we are saying, &quot;Get the value of f (the function referred to)&quot; so that we can do something with it (assign it to another variable, pass it to a function, etc).  The same thing is true of function declarations, which also produce function Objects:  function f() { console.log('f was invoked'); } let f2 = f; f2(); // also invokes the function   The distinction between referring to a function object via its bound variable name (f) vs invoking that same function (f()) is important, because JavaScript programs treat functions as data, just as you would a Number. Consider the following:  function checkUserName(userName, customValidationFn) { // If `customValidationFn` exists, and is a function, use that to validate `userName` if (customValidationFn &amp;&amp; typeof customValidationFn === 'function') { return customValidationFn(userName); } // Otherwise, use a default validation function return defaultValidationFn(userName); }   Here the checkUserName function takes two arguments: the first a String for a username; the second an optional (i.e., may not exist) function to use when validating this username. Depending on whether or not we are passed a function for customValidationFn, we will either use it, or use a default validation function (defined somewhere else).  Notice the line if(customValidationFn &amp;&amp; typeof customValidationFn === 'function') { wherecustomValidationFn is used like any other variable (accessing the value it refers to vs. doing an invocation), to check if it has a value, and if its value is actually a function. Only then is it save to invoke it.  It's important to remember that JavaScript functions aren't executed until they are called via the invocation operator, and may also be used as values without being called. ","version":"Next","tagName":"h3"},{"title":"Operations (CRUD) Reference","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Relational-Database-Postgres/operations-crud-reference","content":"","keywords":"","version":"Next"},{"title":"Create​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingFoundations/Relational-Database-Postgres/operations-crud-reference#create","content":" To create new names in our Name table, we can use the following code:  sequelize.sync().then(() =&gt; { Name.create({ fName: 'Kyler', lName: 'Odin', }).then(() =&gt; { console.log('Kyler Odin created'); }); Name.create({ fName: 'Grier', lName: 'Garrick', }).then(() =&gt; { console.log('Grier Garrick created'); }); Name.create({ fName: 'Kolby', lName: 'Greyson', }).then(() =&gt; { console.log('Kolby Greyson created'); }); });   In the above code we create three new objects following the fields defined in our &quot;Name&quot; model. Since our &quot;Name&quot; model is synchronized with the database, this adds three new records - each with their own unique &quot;id&quot; value, as well as &quot;createdAt&quot; and &quot;updatedAt&quot; values for the implicit primary key and timestamp columns. The create function automatically persists the new object to the database and since it also returns a promise, we can execute code after the operation is complete. In this case we simply output the name to the console.  ","version":"Next","tagName":"h2"},{"title":"Read​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingFoundations/Relational-Database-Postgres/operations-crud-reference#read","content":" To read entries from our Name table, we can use the following code:  sequelize.sync().then(() =&gt; { // return all first names only Name.findAll({ attributes: ['fName'], }).then((data) =&gt; { console.log('All first names'); for (let i = 0; i &lt; data.length; i++) { console.log(data[i].fName); } }); // return all first names where id == 2 Name.findAll({ attributes: ['fName'], where: { id: 2, }, }).then((data) =&gt; { console.log('All first names where id == 2'); for (let i = 0; i &lt; data.length; i++) { console.log(data[i].fName); } }); });   Here, we are once again using a reference to our &quot;Name&quot; model. This time we are using it to fetch data from the &quot;Name&quot; table using the findAll() method. This method takes a number of configuration options in it's object parameter, such as attributes, which allows you to limit the columns that are returned (in this case we only want 'fName') and a where parameter that enables us to specify conditions that the data must meet to be returned. In the above example, id must have a value of 2.  NOTE: It is important to note that trying to log a model instance directly to console.log (ie: console.log(data[i])) will produce a lot of clutter, since Sequelize instances have a lot of things attached to them. Instead, you can use the .toJSON() method (which automatically guarantees the instances to be JSON.stringify-ed well). See sequelize.org - logging instances for more information.  We can also specify an order that the returned data should be in, ie:  sequelize.sync().then(() =&gt; { // return all first names only Name.findAll({ order: ['fName'] }).then((data) =&gt; { console.log('All data'); for (let i = 0; i &lt; data.length; i++) { console.log(data[i].fName); } }); });   NOTE: See the documentation for advanced queries and fetching associated elements with the &quot;include&quot; option when using Model Relationships / Associations (ie: Task.findAll({include:[User]}) )  ","version":"Next","tagName":"h2"},{"title":"Update​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingFoundations/Relational-Database-Postgres/operations-crud-reference#update","content":" To update existing names in our Name table, we can use the following code:  sequelize.sync().then(() =&gt; { // update User 2's last name to &quot;James&quot; // NOTE: this also updates the &quot;updatedAt field&quot; Name.update( { lName: 'James', }, { where: { id: 2 }, // only update user with id == 2 } ).then(() =&gt; { console.log('successfully updated user 2'); }); });   In order to &quot;update&quot; a record in the &quot;Name&quot; table, we make use of the update method. This method takes two parameters: an object that contains all of the properties and (updated) values for a record, and a second object that is used to specify options for the update - most importantly, the &quot;where&quot; property. The &quot;where&quot; property contains an object that is used to specify exactly which record should be updated. In this case, it is the row that has an id value of 2.  ","version":"Next","tagName":"h2"},{"title":"Delete​","type":1,"pageTitle":"Operations (CRUD) Reference","url":"/WebProgrammingFoundations/Relational-Database-Postgres/operations-crud-reference#delete","content":" To delete existing names in our Name table, we can use the following code:  sequelize.sync().then(() =&gt; { // remove User 3 from the database Name.destroy({ where: { id: 3 }, // only remove user with id == 3 }).then(() =&gt; { console.log('successfully removed user 3'); }); });   The delete functionality is actually achieved via a method called destroy. In this case, we invoke the destroy method on the model that contains the record that we wish to remove (ie, &quot;Name&quot;). It takes a single options object as it's only parameter and like the update function, the most important option is the &quot;where&quot; property. The &quot;where&quot; property contains an object that is used to specify exactly which record should be removed. In this case, it is the row that has an id value of 3. ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Security-Considerations/example-code","content":"Example Code You may download the sample code for this topic here: Security-Considerations","keywords":"","version":"Next"},{"title":"HTTPS Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Security-Considerations/https-introduction","content":"","keywords":"","version":"Next"},{"title":"Digital Certificates​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingFoundations/Security-Considerations/https-introduction#digital-certificates","content":" HTTPS uses a protocol known as &quot;TLS&quot; (formerly &quot;SSL&quot; or &quot;Secure Sockets Layer&quot;) to enable secure communication across a network in order to prevent tampering / eavesdropping. This is achieved through the use of something called a &quot;digital certificate&quot;:  Digital Certificates have a key pair: a public and a private key. These keys work together to establish an encrypted connection. The certificate also contains what is called the “subject,” which is the identity of the certificate/website owner. The most important part of a certificate is that it is digitally signed by a trusted CA (&quot;Certificate Authority&quot;), like DigiCert. Anyone can create a certificate, but browsers only trust certificates that come from an organization on their list of trusted CAs. Browsers come with a pre-installed list of trusted CAs, known as the Trusted Root CA store. In order to be added to the Trusted Root CA store and thus become a Certificate Authority, a company must comply with and be audited against security and authentication standards established by the browsers. https://www.digicert.com  Essentially, for a website / app to use HTTPS, a certificate from a trusted source (such as &quot;Digicert&quot;) is required. This certificate contains a &quot;digital signature&quot;, signed by the Certificate Authority (ie: &quot;Digicert&quot;) which proves the validity of the certificate and the website. It also contains a public / private key pair, enabling messages to be encrypted using a public key, but only read using the corresponding private key. Encrypting messages using a trusted website's public key is the first step to enabling two way encrypted communication:  When a web browser (or client) directs to a secured website, the website server shares its TLS/SSL certificate and its public key with the client to establish a secure connection and a unique session key. The browser confirms that it recognizes and trusts the issuer, or Certificate Authority, of the SSL certificate—in this case DigiCert. The browser also checks to ensure the TLS/SSL certificate is unexpired, unrevoked, and that it can be trusted. The browser sends back a symmetric session key and the server decrypts the symmetric session key using its private key. The server then sends back an acknowledgement encrypted with the session key to start the encrypted session. Server and browser now encrypt all transmitted data with the session key. They begin a secure session that protects message privacy, message integrity, and server security.  ","version":"Next","tagName":"h2"},{"title":"Viewing Certificates​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingFoundations/Security-Considerations/https-introduction#viewing-certificates","content":" Information about a website's digital certificate can be easily viewed in a modern web browser. Typically, to the left of the URL bar, you will find a &quot;lock&quot; icon. Click on it to view information about your connection with this website (screenshot taken in Chrome).    Notice how it shows that the site is using a secure connection with an option to &quot;Show Connection Details&quot;. Clicking this allows us to confirm that the certificate is indeed valid and was issued by &quot;DigiCert Inc&quot;.    We may also switch to the &quot;Details&quot; pane, which provides information about the certificate, such as the issuer, expiration date, and the encryption algorithms used.  With this information, we can confirm that sending login credentials and retrieving banking information from CIBC is achieved using encrypted packets between the web browser and server. Anyone who might capture them in transit would not be able to obtain any useful information.  ","version":"Next","tagName":"h3"},{"title":"Self Signed Certificates​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingFoundations/Security-Considerations/https-introduction#self-signed-certificates","content":" SSL/TLS certificates can be created on your own and technically they can be used, however it is important to note that these certificates should not be used in a production environment. This is because using your own &quot;self signed&quot; certificates will result in a warning from the browser that your website is using an &quot;untrusted&quot; certificate, since it did not come from a trusted CA.  ","version":"Next","tagName":"h2"},{"title":"Creating Self Signed Certificates (Development)​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingFoundations/Security-Considerations/https-introduction#creating-self-signed-certificates-development","content":" When testing HTTPS locally and during development, it is common to use a self signed certificate. We can generate them in the terminal using the following command:  openssl req -new -x509 -nodes -out server.crt -keyout server.key   This will initiate the following prompts for information about the organization the certificate will be issued to. The only important one for now is the Common Name - this must be localhost (ie: the domain the certificate will be valid for), since we will be running our server locally:  Generating a 2048 bit RSA private key .............................+++ ...+++ writing new private key to 'server.key' ----- You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter '.', the field will be left blank. ----- Country Name (2 letter code) []:CA State or Province Name (full name) []:ON Locality Name (eg, city) []:Toronto Organization Name (eg, company) []:ACME Widgets Organizational Unit Name (eg, section) []:IT Dept Common Name (e.g. server FQDN or YOUR name) []:localhost Email Address []:   This should generate two files: &quot;server.crt&quot; and &quot;server.key:  ","version":"Next","tagName":"h3"},{"title":"Using SSL Certificates​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingFoundations/Security-Considerations/https-introduction#using-ssl-certificates","content":" Now that we have the required files (ie: &quot;server.crt&quot; and &quot;server.key&quot;), we can begin to configure our &quot;server.js&quot; code to start listening for both HTTP and HTTPS connections:  const fs = require('fs'); const http = require('http'); const https = require('https'); const express = require('express'); const app = express(); const HTTP_PORT = process.env.PORT || 8080; const HTTPS_PORT = 4433; app.get('/', (req, res) =&gt; { res.send('Hello World'); }); // read in the contents of the HTTPS certificate and key const https_options = { key: fs.readFileSync(__dirname + '/server.key'), cert: fs.readFileSync(__dirname + '/server.crt'), }; // listen on ports HTTP_PORT and HTTPS_PORT. http.createServer(app).listen(HTTP_PORT, () =&gt; { console.log(`http server listening on: ${HTTP_PORT}`); }); https.createServer(https_options, app).listen(HTTPS_PORT, () =&gt; { console.log(`https server listening on: ${HTTPS_PORT}`); });   You will notice that a few key changes have been made to our usual &quot;simple web server&quot;. Primarily:  We import both the &quot;http&quot; and &quot;https&quot; modules, as well as the &quot;fs&quot; module (to read the .crt and .key files) Use createServer() method for both &quot;http&quot; and &quot;https&quot;, making sure to provide the values for both the key and cert for the &quot;https_options&quot; parameter when using &quot;https&quot;  Finally, start the server and navigate to: https://localhost:4433  Depending on your web browser, you may observe a security warning if the system is functioning correctly. If you get this warning (with &quot;Advanced&quot; selected) everything is working as intended so far.  ","version":"Next","tagName":"h2"},{"title":"Warning in Firefox​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingFoundations/Security-Considerations/https-introduction#warning-in-firefox","content":"   ","version":"Next","tagName":"h3"},{"title":"Warning in Chrome​","type":1,"pageTitle":"HTTPS Introduction","url":"/WebProgrammingFoundations/Security-Considerations/https-introduction#warning-in-chrome","content":"   NOTE: If you do not see the option to &quot;Proceed to localhost&quot;, then typing &quot;thisisunsafe&quot; will allow you to proceed.  Accept the warnings to add an exemption and proceed to the page. ","version":"Next","tagName":"h3"},{"title":"Getting Started with Vercel","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Resources/vercel-guide","content":"","keywords":"","version":"Next"},{"title":"Required Software​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#required-software","content":" By now, you should have Node.js (available here) and Visual Studio Code (available here). However we will also need git To download git, proceed to this download page and download git for your operating system. Proceed to install git with the default settings. Once this is complete, you can verify that it is installed correctly by opening a command prompt / terminal and issuing the command git --version. This should output something like: git version 2.37.2 ( ... ). If it does not output the installed version of git, then something is wrong and it is not installed correctly. Lastly, for Vercel to gain access to our code, we must eventually place it on GitHub. Therefore, you must also have account on GitHub before proceeding.  ","version":"Next","tagName":"h2"},{"title":"Configuring your App for Vercel​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#configuring-your-app-for-vercel","content":" Before we can start working with Vercel, we must make a few key changes to our code to ensure that it can be successfully deployed on Vercel. These include:  ","version":"Next","tagName":"h2"},{"title":"Adding a \"vercel.json\" file.​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#adding-a-verceljson-file","content":" For our applications (defined in a &quot;server.js&quot; file), we must add the following &quot;vercel.json&quot; file to the root of our project:  { &quot;version&quot;: 2, &quot;builds&quot;: [ { &quot;src&quot;: &quot;server.js&quot;, &quot;use&quot;: &quot;@vercel/node&quot;, &quot;config&quot;: { &quot;includeFiles&quot;: [&quot;dist/**&quot;] } } ], &quot;routes&quot;: [ { &quot;src&quot;: &quot;/(.*)&quot;, &quot;dest&quot;: &quot;server.js&quot; } ] }   ","version":"Next","tagName":"h3"},{"title":"Setting the \"views\" Application Setting​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#setting-the-views-application-setting","content":" If you are using a template engine in your application (ie: EJS), then you will need to add the line:  app.set('views', __dirname + '/views');   before your route definitions.  ","version":"Next","tagName":"h3"},{"title":"Updating your \"express.static()\" Middleware​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#updating-your-expressstatic-middleware","content":" Similarly, if you are using the &quot;express.static()&quot; middleware to define a &quot;public&quot; folder, you must also include the &quot;__dirname&quot; in your path, ie:  app.use(express.static(__dirname + '/public'));   ","version":"Next","tagName":"h3"},{"title":"Explicitly Requiring the \"pg\" Module​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#explicitly-requiring-the-pg-module","content":" If you are using Sequelize with the &quot;pg&quot; / &quot;pg-hstore&quot; modules, Vercel will give you an error if you do not explicitly require the &quot;pg&quot; module, ie:  require('pg'); // explicitly require the &quot;pg&quot; module const Sequelize = require('sequelize');   ","version":"Next","tagName":"h3"},{"title":"Committing Your Code​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#committing-your-code","content":" Once you have configured your code for Vercel and you are ready to publish it, the next steps are to initialize a Git repository at the root of your project folder and push your code to GitHub:  First, issue the following command from the integrated terminal at the &quot;root&quot; folder of your project: git init - this will initialize a local git repository in your helloworld folder. Next, create a file called .gitignore containing the text: node_modules This will ensure that the node_modules folder does not get included in your local git repository Finally, click the &quot;Source Control&quot; icon in the left bar (it should have a blue dot next to it) and type &quot;initial commit&quot; for the message in the &quot;Message&quot; box. Once this is done, click the checkmark above the message box to commit your changes. NOTE: If, at this point, you receive the error: &quot;Git: Failed to execute git&quot;, try executing the following commands in the integrated terminal: git config --global user.email &quot;you@example.com&quot; git config --global user.name &quot;Your Name&quot; Once this is complete, attempt to click the checkmark again to commit your changes.  ","version":"Next","tagName":"h2"},{"title":"Create a GitHub Repository​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#create-a-github-repository","content":" For Vercel to gain access to our code, we must place it on GitHub. Therefore, the next step in this process is creating a GitHub repository for your code:  Sign in to your GitHub account. Find and click a &quot;+&quot; button on the Navigation Bar. Then, choose &quot;New Repository&quot; from the dropdown menu. Fill in the repository name text field with the name of your project. Also, please make sure that the &quot;Private&quot; option is selected: Once you're happy with the settings, hit the &quot;Create repository&quot; button.  ","version":"Next","tagName":"h3"},{"title":"Connect the Local Git Repository to GitHub​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#connect-the-local-git-repository-to-github","content":" Now that our GitHub repository is created, we can proceed to update it with our local copy:  First, go to your newly-created GitHub repository and click the &quot;copy&quot; button in the &quot;Quick Setup&quot; block: This will copy the URL of your remote GitHub repository. Next, go back to your Terminal again and add this remote URL by running the following command: git remote add origin URL   where URL is the remote repository URL that you have copied in the previous step.  To confirm that &quot;origin&quot; was added correctly, run the command: git remote -v. You should see something like this: origin git@github.com:patrick-crawford/helloworld.git (fetch) origin git@github.com:patrick-crawford/helloworld.git (push) Finally, you can push the code from your local repository to the remote one using the command: git push origin master Important Note: If at this point, you see the error: &quot;src refspec master does not match any&quot; then &quot;master&quot; is not set as your default branch. Execute the command git status to determine which branch you're on (it may be &quot;main&quot;) and push that instead, ie: git push origin main, for example  You can verify that the code was pushed by going back to your Browser and opening your GitHub repository.  ","version":"Next","tagName":"h3"},{"title":"Connect the GitHub Repository to Vercel​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#connect-the-github-repository-to-vercel","content":" You should now be ready to push your code to Vercel. First, browse to https://vercel.com and hit the &quot;Start Deploying&quot; button.  Next, press the &quot;Continue with GitHub&quot; button, since our code is located on GitHub. If you are not currently logged in to GitHub, you will need to provide your credentials in a pop-up window before continuing. Once you have logged in to GitHub, you will be taken to the Let's build something new. screen in Vercel, which prompts you to &quot;Import Git Repository&quot;. From here, you will need to click &quot;+ Add GitHub Account&quot; This will prompt you to &quot;Install Vercel&quot;. Feel free to install it for &quot;All repositories&quot; You should now see your repository available for import. To proceed, click Import At the next page, you are not required to make any changes, as Vercel should detect that we are using Node.js. If you had any environment variables, you could set them here as well. Once you are done, click Deploy. Once the deploy step has completed, you should be taken to a &quot;Congratulations!&quot; page with a black button labeled Go To Dashboard. Click this to see the information about your deployment.  ","version":"Next","tagName":"h3"},{"title":"Make Changes and Push to GitHub​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#make-changes-and-push-to-github","content":" Finally, our code is linked to Vercel via. GitHub!  You should now be able to make any changes you wish and trigger a redeploy of your server on Vercel by simply making changes locally, checking in your code using git and &quot;pushing&quot; it to GitHub, using the above instructions.  Good luck and Happy Coding!  ","version":"Next","tagName":"h3"},{"title":"Alternative (Render)​","type":1,"pageTitle":"Getting Started with Vercel","url":"/WebProgrammingFoundations/Resources/vercel-guide#alternative-render","content":" Render, like Vercel, also has a free tier that is available without a credit card or separate account (you can use GitHub to sign in):  &quot;It’s easy to deploy a Web Service on Render. Link your GitHub or GitLab repository and click Create Web Service. Render automatically builds and deploys your service every time you push to your repository. Our platform has native support for Node.js, Python, Ruby, Elixir, Go, and Rust. If these don’t work for you, we can also build and deploy anything with a Dockerfile.&quot; https://render.com/docs/web-services.  Unfortunately, the main drawback of using the free services of Render is that our deployments (web services) are spun down after 15 minutes of inactivity. This will cause a significant delay in the response of the first request after a period of inactivity while the instance spins up.  For more information see the official documentation on &quot;Free Web Services&quot;.  To get started using Render, click the &quot;GET STARTED FOR FREE&quot; button on their main site. This will take you to a login page where you can use your GitHub account for authentication.  Once logged in, click the blue &quot;New +&quot; button in the top menu bar and choose &quot;Web Service&quot;. This will take you to a page where you can choose your GitHub repository for deployment. If you do not see your repository in the &quot;Connect a repository&quot; section, Click &quot;Configure account&quot; under the &quot;GitHub&quot; heading in the right sidebar. This will allow us to grant &quot;Render&quot; permission to all of our repositories (essentially performing the same task that was necessary for Vercel to access our repositories ).  Once this is complete and you can see your repository in the list, click the corresponding &quot;Connect&quot; button. You will then be taken to a screen where you must provide:  A unique name for your web serviceA &quot;start&quot; command (this will typically be &quot;node server.js&quot;, ie: the same &quot;start&quot; command that you will find in your package.json file)  Finally, ensure that the &quot;Free&quot; instance type is checked and click &quot;Create Web Service&quot; and wait for your code to build and deploy. ","version":"Next","tagName":"h2"},{"title":"Password Encryption","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Security-Considerations/password-encryption","content":"","keywords":"","version":"Next"},{"title":"Bcrypt​","type":1,"pageTitle":"Password Encryption","url":"/WebProgrammingFoundations/Security-Considerations/password-encryption#bcrypt","content":" A famous encryption algorithm to achieve &quot;one-way&quot; encryption, is &quot;bcrypt&quot;  bcrypt is a password-hashing function designed by Niels Provos and David Mazières, based on the Blowfish cipher and presented at USENIX in 1999. Besides incorporating a salt to protect against rainbow table attacks, bcrypt is an adaptive function: over time, the iteration count can be increased to make it slower, so it remains resistant to brute-force search attacks even with increasing computation power. https://en.wikipedia.org/wiki/Bcrypt  This sounds like exactly what we need. Fortunately, bcrypt is available on NPM via a module called: &quot;bcrypt.js&quot;.  npm install bcryptjs   const bcrypt = require('bcryptjs');   ","version":"Next","tagName":"h2"},{"title":"Encrypting Passwords​","type":1,"pageTitle":"Password Encryption","url":"/WebProgrammingFoundations/Security-Considerations/password-encryption#encrypting-passwords","content":" If we wish to encrypt a plain text password (ie: &quot;myPassword123&quot;), we can use bcrypt to generate a &quot;salt&quot; and &quot;hash&quot; the text:  // Encrypt the plain text: &quot;myPassword123&quot; bcrypt .hash('myPassword123', 10) .then((hash) =&gt; { // Hash the password using a Salt that was generated using 10 rounds // TODO: Store the resulting &quot;hash&quot; value in the DB }) .catch((err) =&gt; { console.log(err); // Show any errors that occurred during the process });   ","version":"Next","tagName":"h3"},{"title":"Validating Encrypted Passwords​","type":1,"pageTitle":"Password Encryption","url":"/WebProgrammingFoundations/Security-Considerations/password-encryption#validating-encrypted-passwords","content":" If we wish to compare the &quot;hashed&quot; text with plain text (to see if a user-entered password matches the value in the DB), we use:  // Pull the password &quot;hash&quot; value from the DB and compare it to &quot;myPassword123&quot; (match) bcrypt.compare('myPassword123', hash).then((result) =&gt; { // result === true }); // Pull the password &quot;hash&quot; value from the DB and compare it to &quot;myPasswordABC&quot; (does not match) bcrypt.compare('myPasswordABC', hash).then((result) =&gt; { // result === false });  ","version":"Next","tagName":"h3"},{"title":"Sequelize ORM with Postgres","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Relational-Database-Postgres/sequelize-orm-with-postgres","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"Sequelize ORM with Postgres","url":"/WebProgrammingFoundations/Relational-Database-Postgres/sequelize-orm-with-postgres#getting-started","content":" Fortunately, &quot;Sequelize&quot; is packaged as a module on NPM (see: &quot;sequelize&quot;). Therefore to get started, we will need to &quot;install&quot; it as a dependency within our project. With your application folder open in Visual Studio Code, open the integrated terminal and enter the command  npm install sequelize pg pg-hstore   This will add both the sequelize and the pg / pg-hstore modules to our node_modules folder, as well as add their names &amp; version numbers to our package.json file under &quot;dependencies&quot;.  Next, we need to update our server.js file to use the new modules so that we can test our connection to the database. If you're working with an existing application, comment out any existing Express app code (routes, listen, etc.) that you have in server.js (for the time being) and add the following code:  const Sequelize = require('sequelize'); // set up sequelize to point to our postgres database const sequelize = new Sequelize('database', 'user', 'password', { host: 'host', dialect: 'postgres', port: 5432, dialectOptions: { ssl: { rejectUnauthorized: false }, }, }); sequelize .authenticate() .then(() =&gt; { console.log('Connection has been established successfully.'); }) .catch((err) =&gt; { console.log('Unable to connect to the database:', err); });   Where database is your &quot;PGDATABASE&quot; value, user is your &quot;PGUSER&quot; value, password is your &quot;PGPASSWORD&quot; and lastly, host will be your &quot;PGHOST&quot; url (ie: &quot;ab-cd-12345.us-east-2.aws.neon.tech&quot;).  Once you have updated your app to use the Sequelize module, try running it using our usual &quot;node server.js&quot; command. If everything was entered correctly, you should see the following message in the console:  Executing (default): SELECT 1+1 AS result Connection has been established successfully.   Finally, If you see any other errors at this point, go back and check that you have entered all of your credentials correctly when creating the sequelize object. Recall: You can use ctrl + c to stop a node.js application from running.  ","version":"Next","tagName":"h2"},{"title":"Models (Tables) Introduction​","type":1,"pageTitle":"Sequelize ORM with Postgres","url":"/WebProgrammingFoundations/Relational-Database-Postgres/sequelize-orm-with-postgres#models-tables-introduction","content":" Now that we have successfully tested the connection to our Postgres database from our node.js application, we must discuss what the Sequelize module does and how we will be using it to manage data persistence within our Postgres Database.  As we know, sequelize is technically an Object-Relational Mapping (&quot;ORM&quot;) framework. It maps our JavaScript objects (&quot;models&quot;) to tables and rows within our database and will automatically execute relevant SQL commands on the database whenever data using our &quot;models&quot; (JavaScript objects) is updated. This saves us the trouble of manually writing complex SQL statements whenever we wish to update the back-end database to reflect changes made by the user.  To see this in action, update your server.js file to use the following code:  const Sequelize = require('sequelize'); // set up sequelize to point to our postgres database const sequelize = new Sequelize('database', 'user', 'password', { host: 'host', dialect: 'postgres', port: 5432, dialectOptions: { ssl: { rejectUnauthorized: false }, }, }); // Define a &quot;Project&quot; model const Project = sequelize.define('Project', { title: Sequelize.STRING, description: Sequelize.TEXT, }); // synchronize the Database with our models and automatically add the // table if it does not exist sequelize.sync().then(() =&gt; { // create a new &quot;Project&quot; and add it to the database Project.create({ title: 'Project1', description: 'First Project', }) .then((project) =&gt; { // you can now access the newly created Project via the variable project console.log('success!'); }) .catch((error) =&gt; { console.log('something went wrong!'); }); });   Once again, database is your randomly generated “User &amp; Default database” value, user is also your randomly generated “User &amp; Default database” value, password is your password and lastly, host will be your server host url.  There is a lot going on in the above code - but before we walk through what everything is doing, try updating the above code with your database credentials and run it once again with node server.js. You should see the something very similar to the following output:  Executing (default): INSERT INTO &quot;Projects&quot; (&quot;id&quot;,&quot;title&quot;,&quot;description&quot;,&quot;createdAt&quot;,&quot;updatedAt&quot;) VALUES (DEFAULT,'Project1','First Project','2017-02-28 22:45:25.163 +00:00','2017-02-28 22:45:25.163 +00:00') RETURNING \\*; success!   It appears that Sequelize has done some of the heavy lifting for us. To confirm that the create operation was successful and that we have indeed persisted &quot;Project1&quot; in a new &quot;Projects&quot; table, go back to your pgAdmin application, right-click on &quot;Tables&quot; and choose &quot;Refresh&quot;. You should now see our new &quot;Projects&quot; table in the list.  To view the contents of the table, right-click on the &quot;Projects&quot; table and select View / Edit Data &gt; All Rows. This will open a new window with a grid view that you can use to explore the data in the table:    You will notice that there are some columns in the &quot;Project&quot; table that we didn't define in our &quot;Project&quot; Model; specifically: id, createdAt and updatedAt; recall:  // Define a &quot;Project&quot; model const Project = sequelize.define('Project', { title: Sequelize.STRING, description: Sequelize.TEXT, });   It follows that the title and description columns are there, but where did the others come from? The addition of the extra columns are actually added by default by the sequelize module. Whenever we &quot;define&quot; a new model, we automatically get id, createdAt and updatedAt and when we save data using this model, our data is automatically updated to include correct values for those fields. This is extremely handy, as we didn't actually create our primary-key for the table (sequelize went ahead and made &quot;id&quot; our primary key). Also, the createdAt and updatedAt fields are both widely used. However, if we decide that we want to specify our own auto-incrementing primary key and remove the createdAt and updatedAt fields, we can define our model using the following code instead:  // Define a &quot;Project&quot; model const Project = sequelize.define( 'Project', { project_id: { type: Sequelize.INTEGER, primaryKey: true, // use &quot;project_id&quot; as a primary key autoIncrement: true, // automatically increment the value }, title: Sequelize.STRING, description: Sequelize.TEXT, }, { createdAt: false, // disable createdAt updatedAt: false, // disable updatedAt } );   Now that we have defined our Project model (either with or without the &quot;createdAt&quot; and &quot;updatedAt&quot; timestamps) we can look at the rest of the code, ie the sync() operation and creating Project1 - recall:  // synchronize the Database with our models and automatically add the // table if it does not exist sequelize.sync().then(() =&gt; { // create a new &quot;Project&quot; and add it to the database Project.create({ title: 'Project1', description: 'First Project', }) .then((project) =&gt; { // you can now access the newly created Project via the variable project console.log('success!'); }) .catch((error) =&gt; { console.log('something went wrong!'); }); });   The sequelize.sync() operation needs to be completed before we can do anything else. This ensures that all of our models are represented in the database as tables. If we have defined a model in our code that doesn't correspond to a table in the database, sequelize.sync() will automatically create it (as we have seen).  NOTE: We do not have to sync() the database before every operation. This is only required when the server starts to ensure that the models are correctly represented as tables within the database.  Once our models have been successfully sync()'d with the database, we can start working with the data. You will notice that we use the familiar then() and catch() functions; this is because both sync() and create() return a promise and as we stated above, we must work with the data after the sync() operation has successfully completed.  If sync() resolves successfully, we then wish to create a new record in the &quot;Project&quot; table, so we use Project.create() method and pass it some data (title and description). If the operation completed successfully, we see the message &quot;success!&quot; in the console - otherwise we catch the error and output &quot;something went wrong!&quot;  ","version":"Next","tagName":"h2"},{"title":"Defining Models​","type":1,"pageTitle":"Sequelize ORM with Postgres","url":"/WebProgrammingFoundations/Relational-Database-Postgres/sequelize-orm-with-postgres#defining-models","content":" One of the most important things we must do when working with Sequelize is to correctly set up our models. Once the models are set up successfully, working with the data is simple. Since each model technically corresponds to a table within our database, what we are really doing is defining tables. Each column of a table within our database stores a specific type of data. In our previous example, we define the column title as a STRING and the column description as TEXT within a table called Project.  Sequelize provides definitions for a full list of types, and each column is given a type. The following is a list of the most common types:  Sequelize.STRING - A variable length string. Default length 255Sequelize.TEXT - An unlimited length text column.Sequelize.INTEGER - A 32 bit integer.Sequelize.FLOAT - Floating point number (4-byte precision).Sequelize.DOUBLE - Floating point number (8-byte precision)Sequelize.DATE - A datetime columnSequelize.TIME - A time columnSequelize.BOOLEAN - A boolean column  So, if we want to define a model (table) that stores blog entries, we could use the following code:  // Define a &quot;BlogEntry&quot; model const BlogEntry = sequelize.define('BlogEntry', { title: Sequelize.STRING, // entry title author: Sequelize.STRING, // author of the entry entry: Sequelize.TEXT, // main text for the entry views: Sequelize.INTEGER, // number of views postDate: Sequelize.DATE, // Date the entry was posted });   NOTE: It is also possible to introduce data validation when we define our models. For a full list of available rules and how they're implemented, see: Validators in the official documentation.  ","version":"Next","tagName":"h2"},{"title":"Model Relationships / Associations​","type":1,"pageTitle":"Sequelize ORM with Postgres","url":"/WebProgrammingFoundations/Relational-Database-Postgres/sequelize-orm-with-postgres#model-relationships--associations","content":" In a relational database system, tables (models) can be related using foreign key relationships / associations. For example, say we have a table of Users and a table of Tasks, where each User could have 1 or more Tasks. To enforce this relationship, we would add an additional column on the Tasks table as a foreign-key to the Users table, since 1 or more Tasks could belong to a specific user. For example, &quot;Task 1&quot;, &quot;Task 2&quot; and &quot;Task 3&quot; could all belong to &quot;User 1&quot;, whereas &quot;Task 4&quot; and &quot;Task 5&quot; may belong to &quot;User 2&quot;.  Using Sequelize models, we can easily define this relationship using the hasMany() / belongsTo() methods (since &quot;User has many Task(s)&quot;), for example:  // Define our &quot;User&quot; and &quot;Task&quot; models const User = sequelize.define('User', { fullName: Sequelize.STRING, // the user's full name (ie: &quot;Jason Bourne&quot;) title: Sequelize.STRING, // the user's title within the project (ie, developer) }); const Task = sequelize.define('Task', { title: Sequelize.STRING, // title of the task description: Sequelize.TEXT, // main text for the task }); // Associate Tasks with user &amp; automatically create a foreign key // relationship on &quot;Task&quot; via an automatically generated &quot;UserId&quot; field User.hasMany(Task); Task.belongsTo(User);   If we wish to create a User and then assign him some tasks, we can &quot;create&quot; the tasks immediately after the user is created, ie:  sequelize.sync().then(() =&gt; { // Create user &quot;Jason Bourne&quot; User.create({ fullName: 'Jason Bourne', title: 'developer', }).then((user) =&gt; { console.log('user created'); // Create &quot;Task 1&quot; for the new user Task.create({ title: 'Task 1', description: 'Task 1 description', UserId: user.id, // set the correct Userid foreign key }).then(() =&gt; { console.log('Task 1 created'); }); // Create &quot;Task 2&quot; for the new user Task.create({ title: 'Task 2', description: 'Task 2 description', UserId: user.id, // set the correct Userid foreign key }).then(() =&gt; { console.log('Task 2 created'); }); }); });   Next, try running this code and take a look at your database in pgAdmin. You should see that two new tables, &quot;Users&quot; and &quot;Tasks&quot; have been created, with &quot;Jason Bourne&quot; inside the &quot;User&quot; table and &quot;Task 1&quot; and &quot;Task 2&quot; inside the &quot;Task&quot; table. The two new tasks will both have a UserId matching &quot;Jason Bourne&quot;'s id. We have achieved the one-to-many relationship between this user and his tasks.  NOTE: Sequelize also supports other types of relationships using: hasOne()belongsToMany() For more information, refer to &quot;Associations&quot; in the official documentation. ","version":"Next","tagName":"h3"},{"title":"Secure HTTP Headers","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Security-Considerations/secure-http-headers","content":"","keywords":"","version":"Next"},{"title":"Introducing Helmet.js​","type":1,"pageTitle":"Secure HTTP Headers","url":"/WebProgrammingFoundations/Security-Considerations/secure-http-headers#introducing-helmetjs","content":" To help us work with these secure headers, we can use an NPM module called &quot;helmet.js&quot;. Helmet.js functions as middleware in our Node / Express.js applications that automatically sets or removes certain response headers in an effort to enhance security.  To get started using helmet, we must install it from NPM and require it in our server.js code:  npm install helmet   const helmet = require('helmet');   Once it is required, we can use the default configuration by simply invoking it an &quot;app.use()&quot; to register it as middleware, ie:  app.use(helmet());   If you test an express server (ie: our &quot;simple web server&quot;) with this configuration, you should see a similar set of headers have been automatically added to the response:  Response Header\tValueContent-Security-Policy\tdefault-src 'self';base-uri 'self';font-src 'self' https: data:;form-action 'self';frame-ancestors 'self';img-src 'self' data:;object-src 'none';script-src 'self';script-src-attr 'none';style-src 'self' https: 'unsafe-inline';upgrade-insecure-requests Cross-Origin-Opener-Policy\tsame-origin Cross-Origin-Resource-Policy\tsame-origin Origin-Agent-Cluster\t?1 Referrer-Policy\tno-referrer X-Content-Type-Options\tnosniff X-Dns-Prefetch-Control\toff X-Download-Options\tnoopen X-Frame-Options\tSAMEORIGIN X-Permitted-Cross-Domain-Policies\tnone X-Xss-Protection\t0  Additionally, the X-Powered-By header has also been removed.  For configuration options, see the &quot;official Helmet.js documentation&quot; ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Template-Engines/example-code","content":"Example Code You may download the sample code for this topic here: Template-Engines","keywords":"","version":"Next"},{"title":"AJAX Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Web-API-Overview/ajax-introduction","content":"","keywords":"","version":"Next"},{"title":"The Fetch API​","type":1,"pageTitle":"AJAX Introduction","url":"/WebProgrammingFoundations/Web-API-Overview/ajax-introduction#the-fetch-api","content":" In modern browsers, we can use the &quot;Fetch API&quot; to make AJAX requests. Essentially, we can configure a new Request by providing two parameters:  The location of the resourceA set of &quot;options&quot;, (defined using &quot;object literal&quot; notation)  The &quot;location&quot; parameter is simply the URI of the resource, ie: &quot;https://reqres.in/api/users/&quot;, while the &quot;options&quot; parameter could contain any number of options, including:  The http method, ie: 'POST'The 'body' of the request, ie: 'JSON.stringify({user:&quot;John Doe&quot;, job:&quot;unknown&quot;})'An object consisting of a number of headers, ie: '{&quot;Content-Type&quot;: &quot;application/json&quot;}'And Many Others  In practice, this would look something like this:  let myRequest = new Request('https://reqres.in/api/users/', { method: 'POST', body: JSON.stringify({ user: 'John Doe', job: 'unknown' }), headers: { 'Content-Type': 'application/json', }, });   Once the request is configured, we can &quot;Fetch&quot; the data using &quot;fetch()&quot; with our request. This &quot;fetch&quot; method will return a promise that resolves with a &quot;response&quot; object that has a number of methods, including:  response.text() - which we can use to read the 'response' stream. This method returns a promise that will resolve with text.response.json() - which we can use to read the 'response' stream. This method returns a promise that will resolve with an object.  To execute the request defined above (ie: myRequest), we can wire up the &quot;fetch&quot; using the following code (assuming that our resource is returning JSON-formatted data).  fetch(myRequest) .then((response) =&gt; { return response.json(); }) .then((json) =&gt; { console.log(json); // here is the parsed JSON response });   ","version":"Next","tagName":"h2"},{"title":"AJAX: The Fetch API (Compressed)​","type":1,"pageTitle":"AJAX Introduction","url":"/WebProgrammingFoundations/Web-API-Overview/ajax-introduction#ajax-the-fetch-api-compressed","content":" To save lines and make your code more readable and concise, the above two pieces of code can be combined, ie:  fetch('https://reqres.in/api/users/', { method: 'POST', body: JSON.stringify({ user: 'John Doe', job: 'unknown' }), headers: { 'Content-Type': 'application/json' }, }) .then((response) =&gt; response.json()) .then((json) =&gt; { console.log(json); });   NOTE: Our code is even shorter if we're simply doing a &quot;GET&quot; request, ie:  fetch('https://reqres.in/api/users/') .then((response) =&gt; response.json()) .then((json) =&gt; { console.log(json); });   ","version":"Next","tagName":"h3"},{"title":"Handling Responses with an \"Error\" Status​","type":1,"pageTitle":"AJAX Introduction","url":"/WebProgrammingFoundations/Web-API-Overview/ajax-introduction#handling-responses-with-an-error-status","content":" If we wish to handle a situation where the fetch fails, we can always add a catch statement at the end of the above code. However, it is important to note that if the response itself was successful (ie a connnection was made and a response was returned), then the &quot;catch&quot; callback code will not be executed even if the response status code indicates an error, ie 500 or 404. To handle these situations, we can leverage a method on the response object callded &quot;ok&quot; (see: response.ok) which will be true if the status code of the response was in the 200 range. Practically speaking, it can be used like this:  fetch('https://reqres.in/api/unknown/23') .then((response) =&gt; { // return a rejected promise with the status code of the response if it wasn't &quot;ok&quot; return response.ok ? response.json() : Promise.reject(response.status); }) .then((json) =&gt; { console.log(json); }) .catch((err) =&gt; { console.log(err); });  ","version":"Next","tagName":"h2"},{"title":"Built in Objects","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects","content":"","keywords":"","version":"Next"},{"title":"String​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#string","content":" Here are a few examples of how you can declare a String in JavaScript, first using a string literal (which we have already discussed), followed by a call to the new operator and the String object's constructor function:  /* * JavaScript String Literals */ let s = 'some text'; // single-quotes let s1 = 'some text'; // double-quotes let s2 = `some text`; // template literal using back-ticks let unicode = '中文 español Deutsch English देवनागरी العربية português বাংলা русский 日本語 ਪੰਜਾਬੀ 한국어 தமிழ் עברית'; // non-ASCII characters /* * JavaScript String Constructor: `new String()` creates a new instance of a String */ let s3 = new String('Some Text'); let s4 = new String('Some Text');   If we want to convert other types to a String, we have a few options:  let x = 17; let s = '' + x; // concatenate with a string (the empty string) let s2 = String(x); // convert to String. Note: the `new` operator is not used here let s3 = x.toString(); // use a type's .toString() method   Whether you use a literal or the constructor function, in all cases you will be able to use the various functionality of the String type.  ","version":"Next","tagName":"h2"},{"title":"Common Properties and Methods​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#common-properties-and-methods","content":" s.length - will tell us the length of the string (UTF-16 code units) s.charAt(1) - returns the character at the given position (UTF-16 code unit). We can also use s[1] and use an index notation to get a particular character from the string. s.concat() - returns a new string created by concatenating the original with the given arguments. s.padStart(2, '0) - returns a new string padded with the given substring until the length meets the minimum length given. See also s.padEnd(). s.includes(&quot;tex&quot;) - returns true if the search string is found within the string, otherwise false if not found. s.startsWith(&quot;some&quot;) - returns true if the string starts with the given substring, otherwise false. s.endsWith(&quot;text&quot;) - returns true if the string ends with the given substring, otherwise false. s.indexOf(&quot;t&quot;) - returns the first index position of the given substring within s, or -1 if the substring is not found within s. See also s.lastIndexOf() s.match(regex) - tries to match a regular expression against the string, returning the matches. s.replace(regex, &quot;replacement&quot;) - returns a new string with the first occurrence of a matched RegExp replaced by the replacement text. See also s.replaceAll(), which replaces all occurrences. s.slice(2, 3) - returns a new string extracted (sliced) from within the original string. A beginning index and (optional) end index mark the position of the slice. s.split() - returns an Array (see discussion below) of substrings by splitting the original string based on the given separator (String or RegExp). s.toLowerCase() - returns a new string with all characters converted to lower case. s.toUpperCase() - returns a new string with all characters converted to upper case. s.trim() - returns a new string with leading and trailing whitespace removed.  NOTE: JavaScript also supports template literals, also sometimes called template strings. Template literals use back-ticks instead of single- or double-quotes, and allow you to interpolate JavaScript expressions. For example: let a = 1; let s = 'The value is ' + 1 * 6; // Use ${...} to interpolate the value of an expression into a string let templateVersion = `The value is ${1 * 6}`;   ","version":"Next","tagName":"h3"},{"title":"Array​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#array","content":" An Array is also technically an Object with various properties and methods we can use for working with lists in JavaScript.  ","version":"Next","tagName":"h2"},{"title":"Declaring JavaScript Arrays​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#declaring-javascript-arrays","content":" Like creating a String, we can create an Array in JavaScript using either a literal (which we have seen) or the Array constructor function:  let arr = new Array(1, 2, 3); // array constructor let arr2 = [1, 2, 3]; // array literal   ","version":"Next","tagName":"h3"},{"title":"Accessing Elements in an Array​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#accessing-elements-in-an-array","content":" We can use index notation to obtain an element at a given index:  let numbers = [50, 12, 135]; let firstNumber = numbers[0]; let lastNumber = numbers[numbers.length - 1];   JavaScript also allows us to use a technique called Destructuring Assignment to unpack values in an Array into distinct variables. Consider each of the following methods, both of which accomplish the same goal:  // Co-ordinates for Seneca's Newnham Campus let position = [43.796, -79.3486]; // Separate the two values into their own unique variables. // Version 1 - index notation let lat = position[0]; let lng = position[1]; // Version 2 - destructure let [lat, lng] = position;   This technique is useful when working with structured data, where you know exactly how many elements are in an array, and need to access them:  let dateString = `17/02/2001`; let [day, month, year] = dateString.split('/'); console.log(`The day is ${day}, month is ${month}, and year is ${year}`);   Here we .split() the string '17/02/2001' at the '/' character, which will produce the Array ['17', '02', '2001']. Next, we destructure this Array's values into the variables day, month, year.  You can also ignore values (i.e., only unpack the one or ones you want):  let dateString = `17/02/2001`; // Ignore the first index in the array, unpack only position 1 and 2 let [, month, year] = dateString.split('/'); console.log(`The month is ${month}, and year is ${year}`); let emailAddress = `jsmith@myseneca.ca`; // Only unpack the first position, ignoring the second let [username] = emailAddress.split('@'); console.log(`The username for ${emailAddress} is ${username}`);   ","version":"Next","tagName":"h3"},{"title":"Common Properties and Methods​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#common-properties-and-methods-1","content":" arr.length - a property that tells us the number of elements in the array.  Methods that modify the original array  arr.push(element) - a method to add one (or more) element(s) to the end of the array. Using push() modifies the array (increasing its size). You can also use arr.unshift(element) to add one (or more) element to the start of the array.arr.pop() - a method to remove the last element in the array and return it. Using pop() modifies the array (reducing its size). You can also use arr.shift() to remove the first element in the array and return it.  Methods that do not modify the original array  arr.concat([4, 5], 6) - returns a new array with the original array joined together with other arrays or values provided.arr.includes(element) - returns true if the array includes the given element, otherwise false.arr.indexOf(element) - returns the index of the given element in the array, if it exists, otherwise -1 (meaning not found).arr.join(&quot;\\n&quot;) - returns a string created by joining (concatenating) all elements in the array with the given delimiter (String).  Methods for iterating across the elements in an Array  JavaScript's Array type also provides a long list of useful methods for working with list data. All of these methods work in roughly the same way:  // Define an Array let list = [1, 2, 3, 4]; // Define a function that you want to call on each element of the array function operation(element) { // do something with element... } // Call the Array method that you want, passing your function operation list.arrayOperation(operation);   JavaScript will call the given function on every element in the array, one after the other. Using these methods, we are able to work with the elements in an Array instead of only being able to do things with the Array itself.  As a simple example, let's copy our list Array and add 3 to every element. We'll do it once with a for-loop, and the second time with the forEach() method:  // Create a new Array that adds 3 to every item in list, using a for-loop let listCopy = []; for (let i = 0; i &lt; list.length; i++) { let element = list[i]; element += 3; listCopy.push(element); }   Now the same code using the Array's forEach() method:  let listCopy = []; list.forEach(function (element) { listCopy.push(element + 3); });   We've been able to get rid of all the indexing code, and with it, the chance for off-by-one errors. We also don't have to write code to get the element out of the list: we just use the variable passed to our function.  These Array methods are so powerful that there are often functions that do exactly what we need. For example, we could shorten our code above even further but using the map() method. The map() method takes one Array, and calls a function on every element, creating and returning a new Array with those elements:  let listCopy = list.map(function (element) { return element + 3; });   Here are some of the Array methods you should work on learning:  arr.forEach() - calls the provided function on each element in the array.arr.map() - creates and returns a new array constructed by calling the provided function on each element of the original array.arr.find() - finds and returns an element from the array which matches a condition you define. See also arr.findLast(), arr.findIndex(), and arr.findLastIndex(), which all work in similar ways.arr.filter() - creates and returns a new array containing only those elements that match a condition you define in your function.arr.every() - returns true if all of the elements in the array meet a condition you define in your function.  There are more Array methods you can learn as you progress with JavaScript, but these will get you started.  ","version":"Next","tagName":"h3"},{"title":"Iterating over String, Array, and other collections​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#iterating-over-string-array-and-other-collections","content":" The most familiar way to iterate over a String or Array works as you'd expect:  let s = 'Hello World!'; for (let i = 0; i &lt; s.length; i++) { let char = s.charAt(i); console.log(i, char); // Prints: // 0, H // 1, e // 2, l // ... } let arr = [10, 20, 30, 40]; for (let i = 0; i &lt; arr.length; i++) { let elem = arr[i]; console.log(i, elem); // Prints: // 0, 10 // 1, 20 // 2, 30 // ... }   The standard for loop works, but is not the best we can do. Using a for loop is prone to various types of errors: off-by-one errors, for example. It also requires extra code to convert an index counter into an element.  An alternative approach is available in ES6, for...of:  let s = 'Hello World!'; for (let char of s) { console.log(char); // Prints: // H // e // l // ... } let arr = [10, 20, 30, 40]; for (let elem of arr) { console.log(elem); // Prints: // 10 // 20 // 30 // ... }   Using for...of we eliminate the need for a loop counter altogether, which has the added benefit that we'll never under- or over- shoot our collection's element list; we'll always loop across exactly the right number of elements within the given collection.  The for...of loop works with all collection types, from String to Array toarguments to NodeList (as well as newer collection types likeMap,Set, etc.).  ","version":"Next","tagName":"h3"},{"title":"Date​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#date","content":" The Date object represents a single moment in time and provides methods to work with dates and times.  ","version":"Next","tagName":"h2"},{"title":"Creating Dates​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#creating-dates","content":" We can create a new Date object Using the new Date() Constructor  let now = new Date(); // Current date and time   If we wish to set a specific date and time, ie: &quot;May 21st 2024 at 12:34:56&quot; (using a 24-hour format), we have a number of options:  let specificDate = new Date('May 21, 2024 12:34:56'); // DISCOURAGED: may not work in all runtimes let specificDate = new Date('2024-05-21T12:34:56'); // This is standardized and will work reliably let specificDate = new Date(2024, 4, 21); // The month is 0-indexed let specificDate = new Date(2024, 4, 21, 12, 34, 56); // Also passing hours, minutes &amp; seconds let specificDate = new Date(1684639396000); // Passing epoch timestamp   ","version":"Next","tagName":"h3"},{"title":"Common Properties and Methods​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#common-properties-and-methods-2","content":" let currentTime = new Date(); - will give us the current date / time  Methods to Set Individual Parts of the Date Object  let date = new Date(); date.setFullYear(2024); // Sets the year date.setMonth(5); // Sets the month (0-based) date.setDate(21); // Sets the day date.setHours(12); // Sets the hour date.setMinutes(34); // Sets the minutes date.setSeconds(56); // Sets the seconds // etc... (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)   Methods to Get Individual Parts of the Date Object:  let date = new Date(); console.log(date.getFullYear()); // Gets the year console.log(date.getMonth()); // Gets the month (0-based) console.log(date.getDate()); // Gets the day console.log(date.getHours()); // Gets the hour console.log(date.getMinutes()); // Gets the minutes console.log(date.getSeconds()); // Gets the seconds // etc... (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)   Methods to Output the Full Date String  let date = new Date(); console.log(date.toString()); // outputs a string representing this date interpreted in the local timezone console.log(date.toDateString()); // outputs a string representing the date portion of the date interpreted in the local timezone console.log(date.toTimeString()); // outputs a string representing the time portion of the date interpreted in the local timezone console.log(date.toLocaleString('fr-CA')); // outputs a string with a language-sensitive representation of the date and time (ie &quot;Canadian French&quot;) console.log(date.toLocaleDateString('fr-CA')); // outputs a string with a language-sensitive representation of the date portion only (ie &quot;Canadian French&quot;) console.log(date.toLocaleTimeString('fr-CA')); // outputs a string with a language-sensitive representation of the time portion only (ie &quot;Canadian French&quot;) console.log(date.toISOString()); // outputs a string in simplified extended ISO format (always 24 or 27 characters long: YYYY-MM-DDTHH:mm:ss.sssZ or ±YYYYYY-MM-DDTHH:mm:ss.sssZ) console.log(date.toUTCString()); // outputs a string representing the date in UTC (Universal Time Coordinated) time zone   ","version":"Next","tagName":"h3"},{"title":"Comparing Dates​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#comparing-dates","content":" To compare dates, we can use our familiar &quot;greater than&quot; / &quot;less than&quot;, &quot;equals&quot;, etc, operators:  let date1 = new Date(2024, 5, 21); let date2 = new Date(2024, 5, 22); if (date1 &lt; date2) { console.log('Date1 is earlier than Date2'); } else if (date1 &gt; date2) { console.log('Date1 is later than Date2'); } else { console.log('Dates are equal'); }   ","version":"Next","tagName":"h3"},{"title":"Node.js Globals​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#nodejs-globals","content":" The following section outlines some global objects, functions and variables that ship with the Node.js / JavaScript language.  ","version":"Next","tagName":"h2"},{"title":"console​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#console","content":" The console object provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.  Some of the key methods that we will be using are:  console.log()console.time() / console.timeEnd()console.dir()  ","version":"Next","tagName":"h3"},{"title":"__dirname​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#__dirname","content":" __dirname is used to obtain name of the directory that the currently executing script resides in.  For example: if our .js file is located in /Users/pcrawford/ex1.js:  console.log(__dirname); // outputs /Users/pcrawford   ","version":"Next","tagName":"h3"},{"title":"__filename​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#__filename","content":" __filename is be used to obtain file containing the code being executed as well as the directory. This is the resolved absolute path of this code file.  For example: if our .js file is located in /Users/pcrawford/ex1.js:  console.log(__filename); // outputs /Users/pcrawford/ex1.js   ","version":"Next","tagName":"h3"},{"title":"setTimeout()​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#settimeout","content":" The setTimeout() function will execute a piece of code (function) after a certain delay. It accepts 3 parameters:  callback Function: The function to call when the timer elapses.delay number: The number of milliseconds to wait before calling the callback[, …arg] Optional arguments to pass when the callback is called.  For example:  // outputs &quot;Hello after 1 second&quot; to the console setTimeout(function () { console.log('Hello after 1 second'); }, 1000);   ","version":"Next","tagName":"h3"},{"title":"setInterval()​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#setinterval","content":" The setInterval() function will execute a piece of code (function) after a certain delay and continue to call it repeatedly. It accepts 3 parameters (below) and returns a timeout object  callback Function: The function to call when the timer elapses.delay number: The number of milliseconds to wait before calling the callback[, …arg] Optional arguments to pass when the callback is called.  Note: Unless you want the interval to continue forever, you need to call clearInterval() with the timeout object as a parameter to halt the interval  For example:  let count = 1; // global counter let maxCount = 5; // global maximum let myCountInterval = setInterval(function () { console.log('Hello after ' + count++ + ' second(s)'); checkMaximum(); }, 1000); let checkMaximum = function () { if (count &gt; maxCount) { clearInterval(myCountInterval); } };   ","version":"Next","tagName":"h3"},{"title":"URL​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#url","content":" The URL class is used to create a new URL object by parsing the full URL string, ie:  let myURL = new URL('https://myProductInventory.com/products?sort=asc&amp;onSale=true');   Once we have a new URL object, we can access / modify aspects of it via their associated properties:  console.log(myURL); /* URL { href: 'https://myproductinventory.com/products?sort=asc&amp;onSale=true', origin: 'https://myproductinventory.com', protocol: 'https:', username: '', password: '', host: 'myproductinventory.com', hostname: 'myproductinventory.com', port: '', pathname: '/products', search: '?sort=asc&amp;onSale=true', searchParams: URLSearchParams { 'sort' =&gt; 'asc', 'onSale' =&gt; 'true' }, hash: '' */   To access the parsed query parameters (ie the &quot;search&quot; property), we can use a &quot;for...of&quot; loop to iterate over key-value pairs the &quot;searchParams&quot;: property:  for (const [key, value] of myURL.searchParams) { console.log('key: ' + key + ' value: ' + value); } /* key: sort value: asc key: onSale value: true */   ","version":"Next","tagName":"h3"},{"title":"Error​","type":1,"pageTitle":"Built in Objects","url":"/WebProgrammingFoundations/Objects-in-JavaScript/built-in-objects#error","content":" The Error object is used to represent an error (&quot;exception&quot;) that occurs during the execution of our code. It provides a way to capture and handle the exception with useful information such as the error message and the stack trace.  Handling Errors  Consider the following example that generates the runtime error: TypeError: Assignment to constant variable.:  const PI = 3.14159; console.log('trying to change PI!'); PI = 99; console.log('Haha! PI is now: ' + PI);   Here, we are trying to change the value of a constant: PI. If we try to run this short program in Node.js, the program will crash before we get a chance to see the string &quot;Haha! PI is now: 99&quot;, or even &quot;Haha! PI is now: 3.14159&quot;. There is no elegant recovery and we do not exit the program gracefully.  Fortunately, before our program crashes in such a way, Node.js will &quot;throw&quot; an &quot;Error&quot; object that we can intercept using the &quot;try...catch&quot; statement:  const PI = 3.14159; console.log('trying to change PI!'); try { PI = 99; } catch (ex) { console.log('uh oh, an error occurred: ' + ex.message); // outputs: uh oh, an error occurred: Assignment to constant variable. } console.log('Alas, it cannot be done, PI remains: ' + PI);   By utilizing properties such as Error.message &amp; Error.stack, we can gain further insight to exactly what went wrong and we can either refactor our code to remedy the error, or acknowledge that the error will happen and handle it gracefully.  &quot;Throwing&quot; custom Errors  We can also &quot;throw&quot; our own error using the &quot;throw&quot; keyword with a new instance of the &quot;Error&quot; class, for example:  function divide(x, y) { if (y == 0) { throw new Error('Division by Zero!'); } return x / y; } let a = 3, b = 0, c; try { c = divide(a, b); } catch (ex) { console.log(`uh oh, an error occurred: ${ex.message}`); // outputs: uh oh, an error occurred: Division by Zero! c = NaN; } console.log(`${a} / ${b} = ${c}`); // 3 / 0 = NaN  ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Template-Engines/introduction","content":"","keywords":"","version":"Next"},{"title":"Returning HTML & Data​","type":1,"pageTitle":"Introduction","url":"/WebProgrammingFoundations/Template-Engines/introduction#returning-html--data","content":" If we want to return a valid HTML5 page to the client that actually references data stored on the server, one solution would be to build a string that contains both HTML code and data, ie:  app.get('/viewData', function (req, res) { let someData = { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', }; let htmlString = `&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;View Data&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border='1'&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Occupation&lt;/th&gt; &lt;th&gt;Company&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;${someData.name}&lt;/td&gt; &lt;td&gt;${someData.age}&lt;/td&gt; &lt;td&gt;${someData.occupation}&lt;/td&gt; &lt;td&gt;${someData.company}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;`; res.send(htmlString); });   While this will work to send a valid HTML5 page containing our data back to the client, it's clearly not the best way to approach this problem. What if we had a complex page that contains data in different places throughout the layout? We would be building out an enormous string containing normal, static html and in a few places, inserting a reference to our data (someData object). Wouldn't it be better if we could just write a normal HTML document that references the data, instead of having to build one huge string for the whole page?  ","version":"Next","tagName":"h2"},{"title":"Template Engines​","type":1,"pageTitle":"Introduction","url":"/WebProgrammingFoundations/Template-Engines/introduction#template-engines","content":" Fortunately, we can leverage &quot;template engines&quot; with Express to solve this exact problem. From the express.js documentation:  A template engine enables you to use static template files in your application. At runtime, the template engine replaces variables in a template file with actual values, and transforms the template into an HTML file sent to the client. This approach makes it easier to design an HTML page.  This sounds like exactly what we need and there are a number of popular options that we can choose from, such as:  &quot;Pug&quot;&quot;Express Handlebars&quot;&quot;EJS&quot;  In the next section, we will take a look at &quot;EJS&quot;:  A simple templating language that lets you generate HTML markup with plain JavaScript. No religiousness about how to organize things. No reinvention of iteration and control-flow. It's just plain JavaScript. ","version":"Next","tagName":"h2"},{"title":"EJS (Embedded JavaScript Templates)","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates","content":"","keywords":"","version":"Next"},{"title":"Getting Started​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#getting-started","content":" To begin, create the following file in your “views” directory and name it “viewData.ejs”:  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;View Data&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Age&lt;/th&gt; &lt;th&gt;Occupation&lt;/th&gt; &lt;th&gt;Company&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;%= data.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt;   This is a much cleaner approach. We no longer have to generate the full page as a string within our “/viewData” route and most importantly, all of the view logic (HTML) is separate from our control logic (routing).  In order to set this up correctly and get express to understand the file above, we need to modify our server code slightly:  The first thing that we need to do is download / install the EJS package using NPM. Open a terminal in Visual Studio Code (ctrl + ` or View -&gt; Integrated Terminal) and make sure that your working directory is somewhere within your project and run the command npm install ejs This will install the &quot;ejs&quot; package in the same way that we installed the &quot;express&quot; package and update the dependencies in our package.json file: &quot;dependencies&quot;: { &quot;ejs&quot;: ..., &quot;express&quot;: ...&quot; } Next, our server needs to know how to handle HTML files that are formatted using ejs, so near the top of our code (after we define our &quot;app&quot;), add the line: app.set('view engine', 'ejs'); This will tell our server that any file with the &quot;.ejs&quot; extension (instead of &quot;.html&quot;) will use the EJS &quot;engine&quot; (template engine). The final step involves updating our &quot;/viewData&quot; route to &quot;render&quot; our EJS file with the data: app.get('/viewData', function (req, res) { let someData = { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', }; res.render('viewData', { data: someData, }); });   Now, the route no longer returns a string consisting of our HTML + data using res.send(), but instead invokes the render method on the response object (res). We pass the name of our new file without the extension (ie: &quot;viewData&quot; instead of &quot;viewData.ejs&quot;), and a &quot;data&quot; object to hold all of our data (someData).  ","version":"Next","tagName":"h2"},{"title":"EJS Syntax​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#ejs-syntax","content":" Before we begin to discuss the more advanced features of EJS, we must first become familiar with the syntax. For example, we have seen that &lt;%= ... %&gt; is used to render a specific value within our template. However, we should understand that this delimiter (&quot;tag&quot;), also escapes any HTML contained in the value (ie: &quot;&lt;br /&gt;&quot; will be rendered as &quot;&amp;lt;br /&amp;gt;&quot; so that it appears as text, instead of a new line).  The &lt;%= ... %&gt; is not the only delimiter available to us. EJS also provides a number of opening and closing delimiters (&quot;tags&quot;) that control how a value is rendered within the template.  ","version":"Next","tagName":"h2"},{"title":"Delimiters (Tags)​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#delimiters-tags","content":" &lt;%= ... %&gt; (HTML Escaped) As we have seen, this tag outputs the value into the template (HTML escaped). For example: &lt;br /&gt; will be rendered as: &amp;lt;br /&amp;gt;, when using the tag: &lt;%= someValue %&gt; &lt;%- ... %&gt; (Unescaped) This tag works exactly as the above &lt;%= tag, except the value is not HTML escaped.For example: &lt;br /&gt; will be rendered as: &lt;br /&gt;, when using the tag: &lt;%- someValue %&gt; &lt;%# ... %&gt; (Comment) This tag is used when we wish add a comment to our templates that will not be output in the final HTML, ie: &lt;%# This is a comment that will not be rendered %&gt; &lt;% ... %&gt; (Scriptlet) This is the tag that will enable us to insert logic into our templates (discussed further down). For example, if our &quot;data&quot; object contained an array of colors, ie: ['red','green','blue], we could use the following &quot;scriptlet&quot; tags to render the contents using a &quot;forEach&quot; loop: &lt;% data.colors.forEach((color) =&gt; { %&gt; &lt;%= color %&gt; &lt;% }) %&gt;   NOTE: Delimiters that output a value (ie &quot;HTML escaped&quot; / &quot;unescaped&quot;) are also capable of executing JavaScript expressions. For example, if &quot;someValue&quot; is a string, we could use the following code: &lt;%= someValue.toUpperCase() %&gt;  ","version":"Next","tagName":"h3"},{"title":"Includes / \"Partials\"​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#includes--partials","content":" When using EJS, it is also possible to place reusable blocks of our user interface in separate files, such as a common header or an in-page modal window / dialog box. To achieve this, EJS uses an &quot;include&quot; function that may be used in one of the output tags (ie: &quot;HTML escaped&quot; or &quot;unescaped&quot;, however since these included .ejs files typically use HTML, the &quot;unescaped&quot; delimiter is more commonly used).  To see how this works in practice, we will create a &quot;partials&quot; folder within the &quot;views&quot; folder (this will help us separate the reusable templates, from the &quot;page&quot; templates)  Next, (within the &quot;partials&quot; folder) create a file called &quot;header.ejs&quot;:  &lt;h1&gt;EJS Practice - &lt;%= page %&gt;&lt;/h1&gt; &lt;hr /&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/about&quot;&gt;About&lt;/a&gt; | &lt;a href=&quot;/viewData&quot;&gt;View Data&lt;/a&gt; &lt;hr /&gt; &lt;br /&gt;   Notice how our partial template includes a block of reusable HTML as well as an &quot;HTML escaped&quot; tag to render a variable called &quot;page&quot;. To render this template inside another template, we can use the aforementioned &quot;include&quot; function:  File: viewData.ejs  &lt;%- include('partials/header', {page: '/viewData'}) %&gt;   Here, we have used the &quot;unescaped&quot; delimiter to ensure that the HTML within the &quot;partial&quot; is correctly rendered. Additionally, the second parameter contains an object that we an pass to our partial (in this case, the value of the &quot;page&quot; variable)  NOTE: Partial views have access to the data in the template in which they are placed. For example, if the &quot;header&quot; partial (above) was placed in the viewData template, it would have access to the &quot;data&quot; object and could render &quot;data.name&quot;, for example  ","version":"Next","tagName":"h3"},{"title":"Logic​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#logic","content":" Using the &quot;Scriptlet&quot; delimiter (ie: &lt;% ... %&gt;), we can easily insert JavaScript code into our templates. This is one of the key benefits of using EJS:  &quot;We love JavaScript. It's a totally friendly language. All templating languages grow to be Turing-complete. Just cut out the middle-man, and use JS! https://ejs.co  ","version":"Next","tagName":"h2"},{"title":"if / else​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#if--else","content":" To conditionally render portions of our template (HTML), we can use a simple if / else statement. To get this to work correctly, each &quot;line&quot; of JavaScript code should be placed inside a scriptlet delimiter. For example, say we wish to conditionally show our developer &quot;John&quot;:  let someData = { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', visible: true, };   Notice, we have added a &quot;visible&quot; property that we can reference before we render &quot;someData&quot; in our view. Using a simple if / else statement, we can easily hide or show rows in the table:  File: viewData.ejs  &lt;% if (data.visible) { %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= data.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } else { %&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;User: '&lt;%= data.name %&gt;' has hidden their information&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt;   ","version":"Next","tagName":"h3"},{"title":"Iterating over Collections​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#iterating-over-collections","content":" In addition to conditionally rendering portions of our templates, we may also need to display the content of an array / collection. This may be done using the usual constructs, ie &quot;for&quot;, &quot;for...of&quot;, &quot;while&quot;, &quot;forEach()&quot;, etc. For example, if our someData object contained an array of objects:  let someData = [ { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', }, { name: 'Sarah', age: 32, occupation: 'manager', company: 'TD', }, ];   we could use the &quot;forEach()&quot; method to display each object in our table:  File: viewData.ejs  &lt;% data.forEach(user=&gt;{ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= user.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }) %&gt;   Please note that we are not limited to the forEach() loop when iterating over data. As mentioned above, we could also use another construct, such as the &quot;for...of&quot; loop:  &lt;% for (const user of data){ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= user.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt;   ","version":"Next","tagName":"h3"},{"title":"\"Nesting\" Logic​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#nesting-logic","content":" The &quot;scriptlet&quot; tag is extremely powerful - it let's us inject JavaScript into our views to control how our data is displayed. In the above examples, we have only used single pieces of logic at a time (ie: &quot;if/else&quot;, &quot;forEach()&quot;, etc), but it is also possible that this logic may be &quot;nested&quot;.  For example, maybe each of our &quot;users&quot; in the &quot;someData&quot; array has a &quot;visible&quot; property as well. We would like to render each of the elements in the array, but also hide a user if their visible property is set to false  let someData = [ { name: 'John', age: 23, occupation: 'developer', company: 'Scotiabank', visibility: false, }, { name: 'Sarah', age: 32, occupation: 'manager', company: 'TD', visibility: true, }, ];   File: viewData.ejs  &lt;% for (const user of data){ %&gt; &lt;% if(user.visible){ %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= user.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.age %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.occupation %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= user.company %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }else{ %&gt; &lt;tr&gt; &lt;td colspan=&quot;4&quot;&gt;User: '&lt;%= user.name %&gt;' has hidden their information&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;% } %&gt;   ","version":"Next","tagName":"h3"},{"title":"Layouts​","type":1,"pageTitle":"EJS (Embedded JavaScript Templates)","url":"/WebProgrammingFoundations/Template-Engines/ejs-embedded-javaScript-templates#layouts","content":" EJS does not natively support &quot;layouts&quot;. Typically, the structure of an application using EJS as its template engine will feature a common &quot;header, &quot;footer&quot;, &quot;sidebar&quot;, etc with every page, ie:  &lt;body&gt; &lt;%- include('header') %&gt; &lt;%# Page Content / Data Here %&gt; &lt;%- include('footer') %&gt; &lt;/body&gt;   If you wish to customize the 'header' or 'footer' based on the current page, data can be sent to each of the partials separately. For example, one common task is for a navigation bar within the 'header' to highlight the link for the current page. For example, if the user is currently viewing the &quot;/about&quot; route, then &quot;About&quot; should be highlighted:  File: header.ejs  &lt;h1&gt;EJS Practice - &lt;%= page %&gt;&lt;/h1&gt; &lt;hr /&gt; &lt;a href=&quot;/&quot;&gt;Home&lt;/a&gt; | &lt;a href=&quot;/about&quot;&gt;&lt;strong&gt;About&lt;/strong&gt;&lt;/a&gt; | &lt;a href=&quot;/viewData&quot;&gt;View Data&lt;/a&gt; &lt;hr /&gt; &lt;br /&gt;   To achieve this, we can pass the current route to the partial view. Currently, we are passing this value as &quot;page&quot;:  File: viewData.ejs  &lt;%- include('partials/header', {page: '/viewData'}) %&gt;   Therefore, we can leverage the &quot;unescaped&quot; tag to conditionally highlight each of the options using the &quot;ternary&quot; operator, by checking the &quot;href&quot; attribute against the &quot;page&quot; value:  &lt;h1&gt;EJS Practice - &lt;%= page %&gt;&lt;/h1&gt; &lt;hr /&gt; &lt;a href=&quot;/&quot;&gt;&lt;%- (page==&quot;/&quot;) ? '&lt;strong&gt;Home&lt;/strong&gt;' : 'Home' %&gt;&lt;/a&gt; | &lt;a href=&quot;/about&quot;&gt;&lt;%- (page==&quot;/about&quot;) ? '&lt;strong&gt;About&lt;/strong&gt;' : 'About' %&gt;&lt;/a&gt; | &lt;a href=&quot;/viewData&quot;&gt;&lt;%- (page==&quot;/viewData&quot;) ? '&lt;strong&gt;View Data&lt;/strong&gt;' : 'View Data' %&gt;&lt;/a&gt; &lt;hr /&gt; &lt;br /&gt;   NOTE: If you wish to use EJS with full layout support, consider the NPM package: express-ejs-layouts ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Web-API-Overview/example-code","content":"Example Code You may download the sample code for this topic here: Web-API-Overview","keywords":"","version":"Next"},{"title":"API Introduction & Implementation","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Web-API-Overview/api-introduction-and-implementation","content":"","keywords":"","version":"Next"},{"title":"Route Configuration​","type":1,"pageTitle":"API Introduction & Implementation","url":"/WebProgrammingFoundations/Web-API-Overview/api-introduction-and-implementation#route-configuration","content":" Before we think about getting any kind of persistent storage involved however, let's first see how we can configure all of our routes in our server to allow for CRUD operations on a simple collection of users in the format  {userId: number, fName: string, lName: string}   Route\tHTTP Method\tDescription/api/users\tGET\tGet all the users /api/users\tPOST\tCreate a user /api/users/:userId\tGET\tGet a single user /api/users/:userId\tPUT\tUpdate a user with new information /api/users/:userId\tDELETE\tDelete a user  When these routes are applied to our Express server code, we get something that looks like this:  const express = require('express'); const app = express(); const HTTP_PORT = process.env.PORT || 8080; app.get('/api/users', (req, res) =&gt; { res.send({ message: 'fetch all users' }); }); app.post('/api/users', (req, res) =&gt; { res.send({ message: 'add a user' }); }); app.get('/api/users/:userId', (req, res) =&gt; { res.send({ message: `get user with Id: ${req.params.userId}` }); }); app.put('/api/users/:userId', (req, res) =&gt; { res.send({ message: `update User with Id: ${req.params.userId}` }); }); app.delete('/api/users/:userId', (req, res) =&gt; { res.send({ message: `delete User with Id: ${req.params.userId}` }); }); // setup http server to listen on HTTP_PORT app.listen(HTTP_PORT, () =&gt; { console.log(`Express http server listening on: ${HTTP_PORT}`); });   Here, we have made use of the request object's params method to identify the specific user that needs to be fetched, updated or deleted based on the URL alone. In a sense, what we're allowing here is for the URL + HTTP Method to act as a way of querying the data source, as /api/users/3, /api/users/4923 or even /api/users/twelve will all be accepted. They may not necessarily return valid data, but the routes will be found by our server and we can attempt to preform the requested operation.  ","version":"Next","tagName":"h2"},{"title":"AJAX Testing (View)​","type":1,"pageTitle":"API Introduction & Implementation","url":"/WebProgrammingFoundations/Web-API-Overview/api-introduction-and-implementation#ajax-testing-view","content":" Now that we have all of the routes for our API in place, let's create a &quot;view&quot; that will make AJAX requests to test our API functionality. To begin, create a views folder and add the file index.html. This will be a simple HTML page consisting of 5 buttons (each corresponding to a piece of functionality in our API) and some simple JavaScript to make an AJAX request.  However, since we are serving this file from the same server that our API is on, we will need to add some additional code to our server file; specifically:  const path = require('path');   and  app.get('/', (req, res) =&gt; { res.sendFile(path.join(__dirname, '/views/index.html')); });   Finally - our server is setup and ready to serve the index.html file at our main route (&quot;/&quot;). Our next step is to add our client-side logic / JS to the index.html file. Here, we hard-code some requests to the API and output their results to the web console to make sure they function correctly:  &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;API Test&lt;/title&gt; &lt;script&gt; function makeAJAXRequest(method, url, body) { fetch(url, { method: method, body: JSON.stringify(body), // if missing 'body', 'undefined' is returned headers: { 'Content-Type': 'application/json' } }) .then(response =&gt; response.json()) .then(json =&gt; { console.log(json); }); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Test the API by outputting to the browser console:&lt;/p&gt; &lt;!-- Get All Users --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;GET&quot;, &quot;/api/users&quot;)'&gt;Get All Users&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;!-- Add New User --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;POST&quot;, &quot;/api/users&quot;, {fName: &quot;Bob&quot;, lName: &quot;Jones&quot;})'&gt;Add New User&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;!-- Get User By Id --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;GET&quot;, &quot;/api/users/2&quot;)'&gt;Get User&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;!-- Update User By Id --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;PUT&quot;, &quot;/api/users/2&quot;, {fName: &quot;Wanda&quot;, lName: &quot;Smith&quot;})'&gt;Update User&lt;/button&gt;&lt;br /&gt;&lt;br /&gt; &lt;!-- Delete User By Id --&gt; &lt;button type=&quot;button&quot; onclick='makeAJAXRequest(&quot;DELETE&quot;, &quot;/api/users/2&quot;)'&gt;Delete User&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;   ","version":"Next","tagName":"h2"},{"title":"Adding Data (JSON)​","type":1,"pageTitle":"API Introduction & Implementation","url":"/WebProgrammingFoundations/Web-API-Overview/api-introduction-and-implementation#adding-data-json","content":" Once you have entered the above code, save the changes and try running the server locally - you will see that All of the routes tested return a JSON formatted message. This confirms that our Web API will correctly respond to AJAX requests made by the client. Additionally, If you open the Network tab (Google Chrome) before initiating one of the calls to Update or Add a New User, you will see that our request is also carrying a payload of information, ie:    If we wish to capture this information in our routes (so that we can make the appropriate updates to our data source), we must make some small modifications to our server.js file and individual routes (ie: POST to &quot;/api/users&quot; &amp; PUT to &quot;/api/users/:userId&quot;). The first thing that we must do is incorporate middleware to parse the incoming data, ie:  app.use(express.json());   This should allow our routes to access data passed to our API using the req.body property. More specifically, we can update our POST &amp; PUT routes to use req.body to fetch the new / updated fName and lName properties:  app.post('/api/users', (req, res) =&gt; { res.send({ message: `add the user: ${req.body.fName} ${req.body.lName}` }); });   and  app.put('/api/users/:userId', (req, res) =&gt; { res.send({ message: `update User with Id: ${req.params.userId} to ${req.body.fName} ${req.body.lName}` }); });   If we try running the server to test the API again, we will see that the messages returned back from the server correctly echo the data sent to the API. We now have everything that we need to preform simple CRUD operations via AJAX on a data source using a web service. The only thing missing is the data store itself.  NOTE: If we want to allow the API to respond to requests from outside the domain (this is what https://reqres.in does), we will have to enable Cross-Origin Resource Sharing (CORS) - see the third-party CORS middleware ","version":"Next","tagName":"h2"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Web-Server-Introduction/example-code","content":"Example Code You may download the sample code for this topic here: Web-Server-Introduction","keywords":"","version":"Next"},{"title":"JavaScript Object Notation (JSON)","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Web-API-Overview/javascript-object-notation-json","content":"","keywords":"","version":"Next"},{"title":"Converting JSON to an Object​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingFoundations/Web-API-Overview/javascript-object-notation-json#converting-json-to-an-object","content":" let myJSONStr = '{&quot;users&quot;:[{&quot;userId&quot;:1,&quot;fName&quot;:&quot;Joe&quot;,&quot;lName&quot;:&quot;Smith&quot;},{&quot;userId&quot;:2,&quot;fName&quot;:&quot;Jeffrey&quot;,&quot;lName&quot;:&quot;Sherman&quot;},{&quot;userId&quot;:3,&quot;fName&quot;:&quot;Shantell&quot;,&quot;lName&quot;:&quot;McLeod&quot;}]}'; // Convert to An Object: let myObj = JSON.parse(myJSONStr); // Access the 3rd user (Shantell McLeod) console.log(myObj.users[2].fName); // Shantell   ","version":"Next","tagName":"h2"},{"title":"Converting an Object to JSON​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingFoundations/Web-API-Overview/javascript-object-notation-json#converting-an-object-to-json","content":" let myObj = { users: [ { userId: 1, fName: 'Joe', lName: 'Smith' }, { userId: 2, fName: 'Jeffrey', lName: 'Sherman' }, { userId: 3, fName: 'Shantell', lName: 'McLeod' }, ], }; let myJSON = JSON.stringify(myObj); console.log(myJSON); // Outputs: '{&quot;users&quot;:[{&quot;userId&quot;:1,&quot;fName&quot;:&quot;Joe&quot;,&quot;lName&quot;:&quot;Smith&quot;},{&quot;userId&quot;:2,&quot;fName&quot;:&quot;Jeffrey&quot;,&quot;lName&quot;:&quot;Sherman&quot;},{&quot;userId&quot;:3,&quot;fName&quot;:&quot;Shantell&quot;,&quot;lName&quot;:&quot;McLeod&quot;}]}'   ","version":"Next","tagName":"h2"},{"title":"Caveats When Using JSON​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingFoundations/Web-API-Overview/javascript-object-notation-json#caveats-when-using-json","content":" The JSON format works exceptionally well to &quot;serialize&quot; (convert an object in memory to a byte / string representation) and &quot;deserialize&quot; (converting back to an object in memory). However, there are certain things that cannot be encoded to JavaScript Object Notation:  ","version":"Next","tagName":"h2"},{"title":"Object Instances​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingFoundations/Web-API-Overview/javascript-object-notation-json#object-instances","content":" Instances of objects in memory cannot be stored in a JSON format. For example, consider the following &quot;product&quot; object:  let product = { name: 'Pencil', price: 3.95, added: new Date('December 17, 1995 03:24:00'), };   Since the &quot;added&quot; property is an instance of the Date object, we can invoke methods such as &quot;toLocalStimeString()&quot;:  console.log(product.added.toLocaleTimeString('fr-CA')); // 03 h 24 min 00 s   However, if we convert the product to JSON and back, we lose this ability:  // convert to JSON let productJSON = JSON.stringify(product); // restore (convert to object) let productFromJSON = JSON.parse(productJSON); console.log(productFromJSON.added.toLocaleTimeString('fr-CA')); // TypeError: productFromJSON.added.toLocaleTimeString is not a function   This issue occurs because during the conversion to JSON, the Date object was implicitly converted to a string:  { &quot;name&quot;: &quot;Pencil&quot;, &quot;price&quot;: 3.95, &quot;added&quot;: &quot;1995-12-17T08:24:00.000Z&quot; }   ","version":"Next","tagName":"h3"},{"title":"Functions (Methods)​","type":1,"pageTitle":"JavaScript Object Notation (JSON)","url":"/WebProgrammingFoundations/Web-API-Overview/javascript-object-notation-json#functions-methods","content":" Functions (&quot;methods&quot;) that exist on the object also will not convert to JSON. For example:  let counter = { current: 0, increase: function () { this.current++; }, }; console.log(counter.current); // 0 counter.increase(); console.log(counter.current); // 1   Once again, if we attempt to convert this object to JSON and back, we lose the &quot;increase()&quot; function:  // convert to JSON let counterJSON = JSON.stringify(counter); // restore (convert to object) let counterFromJSON = JSON.parse(counterJSON); console.log(counterFromJSON.current); // 0 counterFromJSON.increase(); // TypeError: counterFromJSON.increase is not a function   In this case, this issue occurs because during the conversion to JSON, the &quot;increase&quot; function was not included:  { &quot;current&quot;: 0 }   NOTE: For more information on how values are &quot;stringified&quot;, refer to the MDN documentation on &quot;JSON.stringify()&quot; ","version":"Next","tagName":"h3"},{"title":"Example Code","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Working-With-Forms/example-code","content":"Example Code You may download the sample code for this topic here: Working-With-Forms","keywords":"","version":"Next"},{"title":"HTTP Protocol Overview","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview","content":"","keywords":"","version":"Next"},{"title":"HTTP Requests​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview#http-requests","content":" ","version":"Next","tagName":"h2"},{"title":"Start line​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview#start-line","content":" HTTP requests are messages sent by the client to initiate an action on the server. Their start-line contains of three elements:  An HTTP method that describes the action to be performed:  Method\tDescriptionGET\tThe GET method is used to retrieve information from a specified URI (Universal Resource Identifier) and is assumed to be a safe, repeatable operation by browsers, caches and other HTTP aware components. This means that the operation must have no side effects and GET requests can be re-issued without worrying about the consequences. POST\tThe POST method requests that the target resource process the representation enclosed in the request according to the resource’s own specific semantics. For example, POST is used for the following functions (among others): - Providing a block of data, such as the fields entered into an HTML form, to a data-handling process; - Posting a message to a bulletin board, newsgroup, mailing list, blog, or similar group of articles; - Creating a new resource that has yet to be identified by the origin server; - Appending data to a resource’s existing representation(s). PUT\tThe PUT method is used to request that server store the content included in message body at a location specified by the given URL. For example, this might be a file that will be created or replaced. HEAD\tThe HEAD method is identical to GET except that the server MUST NOT send a message body in the response (i.e., the response terminates at the end of the header section). This method can be used for obtaining metadata about the selected representation without transferring the representation data. DELETE\tThe DELETE method requests that the origin server remove the association between the target resource and its current functionality. In effect, this method is similar to the rm command in UNIX: it expresses a deletion operation on the URI mapping of the origin server. CONNECT\tThe CONNECT method requests that the recipient establish a tunnel to the destination origin server identified by the request-target and, if successful, thereafter restrict its behavior to blind forwarding of packets, in both directions, until the tunnel is closed. Tunnels are commonly used to create an end-to-end virtual connection, through one or more proxies, which can then be secured using TLS (Transport Layer Security). OPTIONS\tThe OPTIONS method requests information about the communication options available for the target resource. This method allows a client to determine the options and/or requirements associated with a resource, or the capabilities of a server, without implying a resource action. TRACE\tThe TRACE method requests a remote, application-level loop-back of the request message. This is typically used to echo the contents of an HTTP Request back to the requester which can be used for debugging purposes during development.  The request target (this can vary between the different HTTP methods) – for example, this can be: An absolute path, optionally followed by a ‘?’ and a query string. This is the most common form, called origin form, and is used with GET, POST, HEAD, and OPTIONS methods, for example: POST / HTTP 1.1GET /background.png HTTP/1.0HEAD /test.html?query=alibaba HTTP/1.1OPTIONS /anypage.html HTTP/1.0 A complete URL, the absolute form, mostly used with GET when connected to a proxy, for example: GET http://developer.mozilla.org/en-US/docs/Web/HTTP/Messages HTTP/1.1 The authority component of an URL, that is the domain name and optionally the port (prefixed by a ‘:’), called the authority form. It is only used with CONNECT when setting up an HTTP tunnel, for example: CONNECT developer.mozilla.org:80 HTTP/1.1 The asterisk form, a simple asterisk (‘*’) used with OPTIONS and representing the server as a whole, for example: OPTIONS * HTTP/1.1 The HTTP version, that defines the structure of the rest of the message, and acts as an indicator of the version to use for the response.  ","version":"Next","tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview#headers","content":" HTTP headers in a request follow the basic structure of any HTTP header: a case-insensitive string followed by a colon (‘:’) and a value whose structure depends upon the header. The whole header, including the value, consists of one single line, that can be quite long.  There are numerous request headers available. In a request, the headers can be divided into two groups:  Request headers: Provide additional context to a request or add extra logic to how it should be treated by a server (e.g., conditional requests).Representation headers: Sent in a request if the message has a body, and they describe the original form of the message data and any encoding applied. This allows the recipient to understand how to reconstruct the resource as it was before it was transmitted over the network.   (https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)  ","version":"Next","tagName":"h3"},{"title":"Body​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview#body","content":" The last part of a request is its body. Not all requests have one: for example, requests fetching resources (like GET or HEAD) usually don’t need any. Similarly, DELETE or OPTIONS also do not require a body.  Other requests send data in the body to the server in order to update it: this is often the case of POST requests (that can have HTML form data).  ","version":"Next","tagName":"h3"},{"title":"HTTP Responses​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview#http-responses","content":" ","version":"Next","tagName":"h2"},{"title":"Status line​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview#status-line","content":" The start line of an HTTP response, called the status line, contains the following information:  The protocol version, usually HTTP/1.1A status code beginning with 1, 2, 3, 4 or 5 that provides information such as the success or failure of the request:  Range\tDescription1xx\tInformational: Request received, continuing process. For example, Microsoft IIS (Internet Information Services) initially replies with 100 (Continue) when it receives a POST request and then with 200 (OK) once it has been processed. 2xx\tSuccess: The action was successfully received, understood, and accepted. For example, the 200 (Ok) status code indicates that the request has succeeded. The meaning of “success” varies depending on the HTTP method, for example: GET: The resource has been fetched and is transmitted in the message body, HEAD: The entity headers are in the message body, POST: The resource describing the result of the action is transmitted in the message body, and TRACE: The message body contains the request message as received by the server 3xx\tRedirection: Further action must be taken in order to complete the request. For example, the 302 (Found) status code indicates that the requested resource has been temporarily moved and the browser should issue a request to the URL supplied in the Location response header. 4xx\tClient Error: The request contains bad syntax or cannot be fulfilled. For example, the famous 404 (Not Found) status code indicates that the server can not find requested resource, or is not willing to disclose that one exists. 5xx\tServer Error: The server failed to fulfill an apparently valid request. For example, the 500 (Internal Server Error) status code indicates that the server encountered an unexpected error / condition that prevented it from fulfilling the request.  A status text, purely informational, that is a textual short description of the status code. This helps HTTP messages be more human-readable, for example: HTTP/1.1 404 Not Found  ","version":"Next","tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview#headers-1","content":" The HTTP header format for responses follow the same basic structure (a case-insensitive string followed by a colon (‘:’) and a value whose structure depends upon the type of the header. The whole header, including the value, stands in one single line)  There are numerous response headers available. In a response, the headers can be divided into two groups:  Response headers: Give additional context about the message or add extra logic to how the client should make subsequent requests. For example, headers like Server include information about the server software, while Date includes when the response was generated. There is also information about the resource being returned, such as its content type (Content-Type), or how it should be cached (Cache-Control).Representation headers: Describe the form of the message data and any encoding applied (if the message has a body). For example, the same resource might be formatted in a particular media type such as XML or JSON, localized to a particular written language or geographical region, and/or compressed or otherwise encoded for transmission. This allows a recipient to understand how to reconstruct the resource as it was before it was transmitted over the network.   (https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages)  ","version":"Next","tagName":"h3"},{"title":"Body​","type":1,"pageTitle":"HTTP Protocol Overview","url":"/WebProgrammingFoundations/Web-Server-Introduction/http-protocol-overview#body-1","content":" The last part of a response is the body. This is typically a single file of known length (defined by the two headers: “Content-Type” and “Content-Length”) or a single file of unknown length (encoded in chunks with the “Transfer-Encoding” header set to “chunked”. However, not all responses have a body, for example: responses with status code like 201 (Created) or 204 (No Content). ","version":"Next","tagName":"h3"},{"title":"Simple Web Server using Express.js","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Web-Server-Introduction/simple-web-server-using-expressjs","content":"","keywords":"","version":"Next"},{"title":"Project Structure​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingFoundations/Web-Server-Introduction/simple-web-server-using-expressjs#project-structure","content":" To get started working with Node.js and Express, we should create a new folder for our application (ie: &quot;MyServer&quot;, as used in the below example). Once this is completed, open it in Visual Studio Code and create the following directory structure by adding &quot;public&quot; and &quot;views&quot; folders as well as a &quot;server.js&quot; file:  /MyServer ↪ /public ↪ /views ↪ server.js   Next, we must open the integrated terminal and create the all-important &quot;package.json&quot; file at the root of our &quot;MyServer&quot; folder, using the command &quot;npm init&quot;.  NOTE: You will be using all of the default options when creating your package.json file  Once this is complete, you should have a new package.json file in your MyServer folder that looks like the following:  { &quot;name&quot;: &quot;myserver&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;server.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;node server.js&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; }   ","version":"Next","tagName":"h2"},{"title":"Express.js​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingFoundations/Web-Server-Introduction/simple-web-server-using-expressjs#expressjs","content":" Express.js is described as:  &quot;a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications.&quot;  Essentially, it is a Node module that takes a lot of the leg work out of creating a framework to build a website. It is extremely popular in the node.js community with a multitude of developers using it to build websites. It is a proven way to build flexible web applications quickly and easily.  To use it in our project we need to use &quot;npm&quot; to install it. From the integrated terminal in Visual Studio code, enter the command:  npm i express   (where &quot;i&quot; is shorthand for the &quot;install&quot; command).  Once this is complete, you should see that your &quot;package.json&quot; file has a new entry that looks like the following (NOTE: Your version may differ from the below):  &quot;dependencies&quot;: { &quot;express&quot;: &quot;^4.18.2&quot; }   You will also notice that a 2nd file was created called &quot;package-lock.json&quot;:  The purpose of package-lock.json is to ensure that the same dependencies are installed consistently across different environments, such as development and production environments. It also helps to prevent issues with installing different package versions, which can lead to conflicts and errors. https://www.atatus.com/blog/package-json-vs-package-lock-json/#package-lock-json  Finally, we also now have the aforementioned &quot;node_modules&quot; folder, which not only contains an &quot;express&quot; folder, but also folders for all of the other modules that &quot;express&quot; depends upon, such as &quot;cookie&quot;, &quot;encodeurl&quot;, &quot;http-errors&quot;, etc.  To begin using Express.js, we must first &quot;require&quot; it in our server.js file and execute the code to start our server. As a starting point, you may use the following boilerplate code:  File: server.js  const express = require('express'); // &quot;require&quot; the Express module const app = express(); // obtain the &quot;app&quot; object const HTTP_PORT = process.env.PORT || 8080; // assign a port // start the server on the port and output a confirmation to the console app.listen(HTTP_PORT, () =&gt; console.log(`server listening on: ${HTTP_PORT}`));   The above code will be used in nearly every server written using &quot;Express&quot; in these notes. As mentioned above, it &quot;requires&quot; the Express module, which is then invoked as a function to get an &quot;app&quot; object, which is used to start our server on a given HTTP Port. The reason that the HTTP_PORT constant is defined as process.env.PORT || 8080 is because when we move our server online, it will be assigned a different port, using a &quot;PORT&quot; environment variable.  If we now want to start our server, we can simply execute the &quot;server.js&quot; file using node:  node --watch server.js   NOTE: the &quot;--watch&quot; flag will cause Node to run in &quot;watch&quot; mode, which will restart the process when a change is detected  If you open a browser to: http://localhost:8080, you should see the following message:  Cannot GET /   Congratulations! Your web server is up and running! Unfortunately, we don't have any &quot;routes&quot; (ie: paths to pages / resources) defined yet, so the Express framework automatically generated a 404 error for the path that we tried to access (ie: GET /)  NOTE: To stop the server from running, you may use the Ctrl+C command from the integrated terminal in Visual Studio Code  ","version":"Next","tagName":"h2"},{"title":"Simple 'GET' Routes​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingFoundations/Web-Server-Introduction/simple-web-server-using-expressjs#simple-get-routes","content":" As you have seen from running our server, not much is happening. Even if we try to navigate around to other paths such as &quot;http://localhost:8080/about&quot; (thereby making a &quot;GET&quot; request to the &quot;/about&quot; path (route)), we will keep getting the same 404 error: &quot;Cannot GET&quot;. This is because we have not defined any &quot;GET&quot; routes within our server.  To fix this, we must write code in our server.js file to correctly respond to these types of requests. This can be accomplished using the &quot;app&quot; object, that was used to start our server. If we wish to respond to a &quot;GET&quot; request, we must invoke a &quot;GET&quot; function and provide the target path as well as a &quot;callback&quot; function to handle the request. For example, if we wish to respond to a &quot;GET&quot; request on the &quot;/&quot; route, we would write the following code before the call to app.listen();  app.get('/', (req, res) =&gt; { res.send('Hello World!'); });   Here, we have specified a callback function to be executed when our server encounters a &quot;GET&quot; request for the &quot;/&quot; route. It will be invoked with the following parameters:  &quot;req&quot;: The &quot;request&quot; object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on.&quot;res&quot;: &quot;The &quot;response&quot; object represents the HTTP response that an Express app sends when it gets an HTTP request  In the above case, we use the &quot;res&quot; object's &quot;send&quot; method to send a response back to the client.  If we wish to have a second route, all we have to do is add another call to &quot;app.get()&quot; with the new path. This is how we will define any path &quot;route&quot; that we wish our server to respond to, when it encounters a &quot;GET&quot; request from a web client (ie: web browser):  app.get('/about', (req, res) =&gt; { res.send('About the Company'); });   Now, we should be able to navigate to both: http://localhost:8080 and http://localhost:8080/about and see the text sent by our server.  ","version":"Next","tagName":"h3"},{"title":"Returning .html Files​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingFoundations/Web-Server-Introduction/simple-web-server-using-expressjs#returning-html-files","content":" Returning plain text is fine to test if our routes are configured properly, however if we want to start making web applications, we should be returning valid HTML documents. To get started, we will create two simple .html files within the &quot;views&quot; folder:  File: /MyServer/views/home.html  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Home&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome Home&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;/about&quot;&gt;About the Company&lt;/a&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   File: /MyServer/views/about.html  &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;About&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;About the Company&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;/&quot;&gt;Back Home&lt;/a&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;   Next, we must update our route definitions to return these documents instead of the simple messages: &quot;Hello World!&quot; and &quot;About the Company&quot;. To achieve this, we will be using the &quot;sendFile()&quot; method of the &quot;res&quot; object, instead of &quot;send()&quot;.  For &quot;sendFile()&quot; to function correctly, we must provide an absolute path to the file we wish to send as a parameter to the function. As you know, we cannot hard-code this path into our server.js, as this path will differ depending on which machine is executing the code - for example: the service the app is deployed on, vs. your local computer.  This is where knowledge of the built-in &quot;path&quot; module and the __dirname global come into play.  At the top of your server file, we will require &quot;path&quot;;  const path = require('path');   Next, we can update our routes to use &quot;sendFile()&quot; as follows:  res.sendFile(path.join(__dirname, '/views/someFile.html'));   where &quot;someFile.html&quot; would be any file that you wish to send back to the client, from your &quot;views&quot; folder, ie: &quot;home.html&quot; or &quot;about.html&quot;. We use path.join() to safely join the &quot;__dirname&quot; path with the local path to the file. Together, this results in an absolute path that is not tied to a specific machine.  ","version":"Next","tagName":"h3"},{"title":"CSS & Images​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingFoundations/Web-Server-Introduction/simple-web-server-using-expressjs#css--images","content":" Now that we know how to send complete HTML files back to the client, the next step is including &quot;static&quot; resources, ie: images, CSS, etc. So far, if we wish to respond to a request from a client we must have an explicit &quot;route&quot; configured. For example, the &quot;/about&quot; route only works because we have defined the corresponding app.get(&quot;/about&quot;, ...) function call. What happens when a request for a static resources is requested? Do we have to have a specific root configured for every resource? Thankfully, the answer is no.  Using Express, we can identify a specific folder as &quot;static&quot; and any valid requests for resources contained within that folder are automatically sent back to the client with a 200 status code.  Using our existing project structure, we can use the &quot;public&quot; folder as our static folder and place any static resources in there. For example, if we want a custom CSS file, we could place it in:  /MyServer ↪ /public ↪ /css ↪ site.css   We could then link to it in our HTML documents the code:  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/site.css&quot; /&gt;   NOTE: The same pattern would work for images as well, ie: /MyServer ↪ /public ↪ /img ↪ banner.jpg &lt;img src=&quot;/img/banner.jpg&quot; alt=&quot;site banner&quot; /&gt;   Notice how we do not include &quot;/public&quot; in the href (or src) properties. This is because we will mark &quot;/public&quot; as the official &quot;static&quot; folder and all requests must made to resources within the folder. To accomplish this in our server.js file, we can add the following code above the other app.get() function calls:  app.use(express.static('public'));   Here, we have used &quot;express.static()&quot; - a built-in middleware function (explained later in these notes) to mark the &quot;public&quot; directory as static. With this code in place, whenever a request is sent to our server, Express will first check to see if the requested resource exists in the &quot;public&quot; folder, before checking our other routes.  ","version":"Next","tagName":"h3"},{"title":"Public Hosting (Vercel)​","type":1,"pageTitle":"Simple Web Server using Express.js","url":"/WebProgrammingFoundations/Web-Server-Introduction/simple-web-server-using-expressjs#public-hosting-vercel","content":" As a final exercise, review the documentation on &quot;Getting Started with Vercel&quot; and see if you can get the server running online! ","version":"Next","tagName":"h2"},{"title":"Modules & Node Package Manager","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Web-Server-Introduction/modules-node-package-manager","content":"","keywords":"","version":"Next"},{"title":"Built-In Modules / 'require()'​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingFoundations/Web-Server-Introduction/modules-node-package-manager#built-in-modules--require","content":" While referencing the official Node.js Documentation, you may have noticed that some of the examples include a mandatory 'require()' statement. For example, if we try to execute this simplified 'EventEmitter' sample:  const myEmitter = new EventEmitter(); myEmitter.on('event', function () { console.log('an event occurred!'); }); myEmitter.emit('event');   we run into an error: ReferenceError: EventEmitter is not defined. As you will have guessed, this is because our running script does not know about the &quot;EventEmitter&quot; class, as it is not global. To remedy this, we can include the required class by &quot;requiring&quot; it, with the following syntax:  const EventEmitter = require('events'); const myEmitter = new EventEmitter(); myEmitter.on('event', function () { console.log('an event occurred!'); }); myEmitter.emit('event');   By using the global 'require' function, we have loaded a code &quot;module&quot; which contains code and logic that we can use in our own solutions. We will discuss modules in detail below, however for now we should be aware of the following &quot;Built-In&quot; modules:  ","version":"Next","tagName":"h2"},{"title":"fs​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingFoundations/Web-Server-Introduction/modules-node-package-manager#fs","content":" The 'fs' module is used to work directly with the file system (ie: read / write files, list the contents of a directory, etc). For example, if we had a CSV file with names, (ie: names.csv):  Jacob,Alexandra,Jessie,Ranya,Felix   We could read the contents of the file and convert the list into an array:  const fs = require('fs'); fs.readFile('names.csv', function (err, fileData) { if (err) console.log(err); else { namesArray = fileData.toString().split(','); console.log(namesArray); } });   Similarly, if we had a directory of images, ie: &quot;img&quot;, we could list the files using:  const fs = require('fs'); fs.readdir('img', function (err, filesArray) { if (err) console.log(err); else { console.log(filesArray); } });   ","version":"Next","tagName":"h3"},{"title":"path​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingFoundations/Web-Server-Introduction/modules-node-package-manager#path","content":" The 'path' module provides utilities for working with file and directory paths. This will be useful when working with reading template files or writing uploaded files. For example, it can easily be used to safely concatenate two directories / paths together:  const path = require('path'); console.log('Absolute path to about.html'); console.log(path.join(__dirname, '/about.html')); // with leading slash console.log(path.join(__dirname, '//about.html')); // with multiple leading slashes console.log(path.join(__dirname, 'about.html')); // without leading slash console.log(path.join(__dirname, '\\about.html')); // with incorrect leading slash   ","version":"Next","tagName":"h3"},{"title":"Writing Modules​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingFoundations/Web-Server-Introduction/modules-node-package-manager#writing-modules","content":" We can also create our own modules that work the same way, by making use of a global “module” object – which isn’t truly “global” in the same sense as “console”, but instead global to each of your modules, which are located in separate .js files. For example, consider the two following files (modEx1.js: the main file that Node will execute, and message.js: the file containing the module):  file ./modEx1.js  let message = require('./modules/message'); message.writeMessage('Hello World!'); message.readMessage();   file: ./modules/message.js  // NOTE: Node.js wraps the contents of this file in a function: // (function (exports, require, module, __filename, __dirname) { ... }); // so that we have access to the working file/directory names as well // as creating an isolated scope for the module, so that our // variables are not global. let localFunction = () =&gt; { // a function local to this module }; let localMessage = ''; module.exports.writeMessage = (msg) =&gt; { localMessage = msg; }; module.exports.readMessage = () =&gt; { console.log(`${localMessage} from ${__filename}`); };   Executing the code in modEx1.js (ie: node modEx1.js) should output:  “Hello World” from …  where … is the absolute location of the message.js file in your system, for example: /Users/pat/Desktop/Seneca/modules/message.js  Notice how our “message” module uses the exports property of the “module” object to store functions and data that we want to be accessible in the object returned from the require(“./modules/message”); function call from modEx1.js. Generally speaking, if you want to add anything to the object returned by “require” for your module, it’s added to the module.exports object from within your module. In this case, we only added two functions (readMessage() and writeMessage()).  Using this methodology, we can safely create reusable code in an isolated way that can easily be added (plugged in) to another .js file.  ","version":"Next","tagName":"h2"},{"title":"NPM – Node Package Manager​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingFoundations/Web-Server-Introduction/modules-node-package-manager#npm--node-package-manager","content":" The Node Package Manager is a core piece of the module based Node ecosystem. The package manager allows us to install and manage 3rd party modules, available from https://www.npmjs.com within our own applications.  From the npm documentation:  npm is the world's largest software registry. Open source developers from every continent use npm to share and borrow packages, and many organizations use npm to manage private development as well. npm consists of three distinct components: the websitethe Command Line Interface (CLI)the registry Use the website to discover packages, set up profiles, and manage other aspects of your npm experience. For example, you can set up organizations to manage access to public or private packages. The CLI runs from a terminal, and is how most developers interact with npm. The registry is a large public database of JavaScript software and the meta-information surrounding it.  The CLI is installed by default when you install Node. From the command line you can run ‘npm’ with various commands to download and remove packages for use with your Node applications. When you have installed a package from npm you use it in the same way as using your own modules like above, with the require() function.  All npm packages that you install locally for your application will be installed in a node_modules folder in your project folder.  While there are over 60 &quot;npm&quot; commands available, the ones that we will most commonly use in this course are as follows:  Command\tDescriptionnpm install [Module Name]\tinstall is used to install a package from the npm repository so that you can use it with your application. ie: let express = require(&quot;express&quot;); npm uninstall [module name]\tuninstall does exactly what you would think, it uninstalls a module from the node_modules folder and your application will no longer be able to require() it. npm init\tcreate a new package.json file for a fresh application. More on this part later. npm prune\tThe prune command will look through your package.json file and remove any npm modules that are installed that are not required for your project. More on this part later. npm list\tShow a list of all packages installed for use by this application.  ","version":"Next","tagName":"h2"},{"title":"Globally installing packages​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingFoundations/Web-Server-Introduction/modules-node-package-manager#globally-installing-packages","content":" Every so often, you will want to install a package globally. Installing a package globally means you will install it like an application on your computer which you can run from the command line, not use it in your application code. For example, some npm packages are tools that are used as part of your development process on your application:  One example is the migrate package which allows you to write migration scripts for your application that can migrate your data in your database and keep track of which files have been run.  Another example is grunt-cli so that you can run grunt commands from the command line to do things like setup tasks for running unit tests or checking for formatting errors in code before pushing up new code to a repository.  A third example is bower. Bower is a package manager similar to npm but typically used for client side package management. To install a package globally you just add the -g switch to your npm install command. For example:  npm install bower -g   Globally installed packages do not get installed in your node_modules folder and instead are installed in a folder in your user directory. The folder uses for global packages varies for Windows, Mac, and Linux. See the documentation if you need to find globally installed packages on your machine.  ","version":"Next","tagName":"h3"},{"title":"package.json explained​","type":1,"pageTitle":"Modules & Node Package Manager","url":"/WebProgrammingFoundations/Web-Server-Introduction/modules-node-package-manager#packagejson-explained","content":" The Node Package Manager is great. It provides an easy way to download reusable packages or publish your own for other developers to use. However, there are a few problems with sharing modules and using other modules, once you want to work on an application with someone else. For example:  How are you going to make sure everyone working on your project has all the packages the application requires? How are you going to make sure everyone has the same version of all those packages? Finally, how are you going to handle updating a package and making sure everyone else on your project updates as well?  This is where the package.json file comes in.  The package.json file is a listing of all the packages your application requires and also which versions are required. It provides a simple way for newcomers to your project to get started easily and stay up to date when packages get updated.  The npm documentation for the package.json file has all the information you will need as you begin building applications in node.js  Let’s look at how we can generate a package.json file using the npm init command from within your project's folder (in this case: &quot;/Users/pat/Desktop/Seneca/&quot;):  $ npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sensible defaults. See `npm help init` for definitive documentation on these fields and exactly what they do. Use `npm install &lt;pkg&gt;` afterwards to install a package and save it as a dependency in the package.json file. Press ^C at any time to quit. package name: (seneca) version: (1.0.0) description: entry point: (index.js) test command: git repository: keywords: author: license: (ISC) About to write to /Users/pat/Desktop/Seneca/package.json: { &quot;name&quot;: &quot;seneca&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; } Is this OK? (yes)   If you try running this command yourself, you will see that the process is interactive, ie: you will be prompted to enter everything from the &quot;package name&quot; to the &quot;license&quot;. Any values that you see in brackets &quot;()&quot; are default values and will be accepted if you press &quot;Enter&quot;.  Once this process is done, you will see that you have a new file created in your project called package.json. In the above case, it will look like this:  { &quot;name&quot;: &quot;seneca&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot; }   Once generated, you can edit it if you decide to change the name or version (for example). Once you decide to add packages to your app you can simply install the package with npm install. This will save the package and version into the package.json file for you so that when others want to work on your app, they will have the package.json file and can use npm install to install all the required dependencies with the right version. Think of package.json as a checklist for your application for all of its dependencies. ","version":"Next","tagName":"h3"},{"title":"Processing Multipart Form Data","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Working-With-Forms/processing-multipart-form-data","content":"","keywords":"","version":"Next"},{"title":"Processing the Data with Middleware​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingFoundations/Working-With-Forms/processing-multipart-form-data#processing-the-data-with-middleware","content":" Recall, when working with url-encoded data, we had to use &quot;Middleware&quot; (specifically the built-in middleware: express.urlencoded()) to process the data and deliver it in a format that we can process. This is also the case for &quot;multipart/form-data&quot;, however there are no available built-in middleware functions that we can use. Instead, we will use the popular third-party middleware: &quot;Multer&quot;  Multer is a node.js middleware for handling multipart/form-data, which is primarily used for uploading files. It is written on top of busboy for maximum efficiency. NOTE: Multer will not process any form which is not multipart (multipart/form-data).  To get started using Multer, we will need to install it:  npm install multer   Next, we must require the module and configure the middleware, ie:  const multer = require('multer');   ","version":"Next","tagName":"h2"},{"title":"Default (Simple) configuration​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingFoundations/Working-With-Forms/processing-multipart-form-data#default-simple-configuration","content":" To begin, we will use the default configuration for Multer. All that is required is a &quot;dest&quot; property that defines where the files will go once uploaded. In this case, we will use the folder &quot;uploads/&quot;:  const upload = multer({ dest: 'uploads/' });   ","version":"Next","tagName":"h3"},{"title":"Writing The Route Handler​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingFoundations/Working-With-Forms/processing-multipart-form-data#writing-the-route-handler","content":" With our middleware in place, we can now write our route handler for the route defined in our &quot;action&quot; attribute: &quot;/uploadEntry&quot;. When using Multer, we not only have access to the &quot;req.body&quot; property to get the data submitted in the form, but also a &quot;req.file&quot; property to get information about the uploaded file:  app.post('/uploadEntry', upload.single('avatar'), (req, res) =&gt; { res.send({ body: req.body, file: req.file }); });   Notice how we apply the middleware on the specific route, rather than using &quot;app.use()&quot;. Additionally, since we're uploading a single image, we invoke the &quot;single&quot; method, passing the &quot;name&quot; attribute for our &lt;input type=&quot;file&quot;&gt; (ie: &quot;avatar&quot;).  If we try submitting the form again, we should see a result in the browser with both the form and file upload information (ie: &quot;req.body&quot; &amp; &quot;req.file&quot;).  While this does indeed work and the file is uploaded to the correct destination (the &quot;uploads&quot; folder, as specified), we do not have any control over how the file is named. Additionally, we lose the file extension associated with the file. To gain more control over the file upload, we will need to perform some additional configuration.  ","version":"Next","tagName":"h2"},{"title":"Additional Configuration (diskStorage)​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingFoundations/Working-With-Forms/processing-multipart-form-data#additional-configuration-diskstorage","content":" In order to customize the filename of the upload, we will need to use the &quot;diskStorage&quot; option when we configure our &quot;upload&quot; middleware. Here, instead of creating &quot;upload&quot; using multer({ dest: 'uploads/' });, we will use the following &quot;diskStorage&quot; configuration:  const storage = multer.diskStorage({ destination: 'uploads/', filename: function (req, file, cb) { cb(null, Date.now() + path.extname(file.originalname)); }, }); const upload = multer({ storage: storage });   Here, we specify the filename to be a current date, using &quot;Date.now()&quot;, ie:  The number of milliseconds elapsed since the epoch, which is defined as the midnight at the beginning of January 1, 1970, UTC.  We also retain the current extension using path.extname() from the &quot;path&quot; module: const path = require(&quot;path&quot;);  ","version":"Next","tagName":"h2"},{"title":"Ephemeral / Read-Only File Systems​","type":1,"pageTitle":"Processing Multipart Form Data","url":"/WebProgrammingFoundations/Working-With-Forms/processing-multipart-form-data#ephemeral--read-only-file-systems","content":" As a final note, it's important to consider that many cloud-based hosting providers either have an &quot;ephemeral&quot; file system (ie: data is not persisted across deploys and restarts) or the file system is read-only. In this case, if we wish to persist file uploads, we could use a library like &quot;streamifier&quot; to create a readable stream of the file data, rather than store it. We could then pass the data to a free service like &quot;Cloudinary&quot; to host the file.  For more information, see the Cloudinary documentation on Uploading assets / Upload data stream ","version":"Next","tagName":"h2"},{"title":"HTML Form Elements Overview","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview","content":"","keywords":"","version":"Next"},{"title":"Form​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#form","content":" The form element serves as the primary container for housing your form, including user inputs and the submit button. It has several attributes that control its behavior, with the most common ones being 'enctype', 'method', and 'action'.  The enctype is the encoding type. If you are working with forms that have file uploads that accompany the form data, this value should be set to: multipart/form-data, otherwise the default is application/x-www-form-urlencoded. The 'method' specifies which HTTP verb to use when making the submission request (ie: &quot;GET: or &quot;POST&quot;). Finally, the 'action' attribute is the URL / route that the form will send the request to once it has been submitted.  &lt;form method=&quot;post&quot; enctype=&quot;application/x-www-form-urlencoded&quot; action=&quot;https://httpbin.org/post&quot;&gt; &lt;!-- ... --&gt; &lt;/form&gt;   NOTE: in the above example, &quot;enctype&quot; may be omitted since &quot;application/x-www-form-urlencoded&quot; is the default value for &quot;enctype&quot;  ","version":"Next","tagName":"h2"},{"title":"Input​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#input","content":" The input element creates a single-line text box by default (ie: the default value for the 'type' attribute is text):  &lt;input type=&quot;text&quot; name=&quot;fullName&quot; /&gt;   NOTE: We must ensure that every form control includes a &quot;name&quot; field, which will be used to identify the form value, when submitted.  There are also a multitude of additional interactive input 'types' that may be used, such as:  color: Elements of type=&quot;color&quot; provide a user interface element that lets a user specify a color, either by using a visual color picker interface or by entering the color into a text field in #rrggbb hexadecimal format. date: Elements of type=&quot;date&quot; create input fields that let the user enter a date, either with a textbox that validates the input or a special date picker interface. time: Elements of type=&quot;time&quot; create input fields designed to let the user easily enter a time (hours and minutes, and optionally seconds). email: Elements of type=&quot;email&quot; are used to let the user enter and edit an email address, or, if the multiple attribute is specified, a list of email addresses. number: Elements of type=&quot;number&quot; are used to let the user enter a number. They include built-in validation to reject non-numerical entries. range: Elements of type=&quot;range&quot; let the user specify a numeric value which must be no less than a given value, and no more than another given value. The precise value, however, is not considered important. This is typically represented using a slider or dial control rather than a text entry box like the number input type. file: Elements of type=&quot;file&quot; let the user choose one or more files from their device storage. Once chosen, the files can be uploaded to a server using form submission, or manipulated using JavaScript code and the File API.  ","version":"Next","tagName":"h2"},{"title":"Textarea​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#textarea","content":" The textarea element is much like an &lt;input type='text'&gt; input, except it allows multiple lines of text. Essentially, it is a text box that has space to add a larger quantity of text, instead of just a single line of text. The textarea is useful for capturing user input that would typically be long and detailed or several sentences long.  &lt;textarea name=&quot;blogEntry&quot;&gt;&lt;/textarea&gt;   ","version":"Next","tagName":"h2"},{"title":"Select​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#select","content":" The select element serves as a &quot;dropdown list&quot; of option elements for users to choose from. Used without any attributes, it behaves exactly like a dropdown list and only permits the user to select 1 (one) &quot;option&quot;. With the addition of the &quot;multiple&quot; attribute, we can allow the user to select more than one option. We can also specify a &quot;size&quot; attribute, to show more than a single option at a time - this will work for both &lt;select&gt; and &lt;select multiple&gt; elements. When submitted, the value is the text in the &quot;value&quot; attribute for the selected option. When multiple options are selected, an array of &quot;value&quot; attributes are submitted, ie: [&quot;car&quot;, &quot;bus&quot;].  &lt;select name=&quot;pet&quot;&gt; &lt;option value=&quot;&quot;&gt;-- Please choose an option --&lt;/option&gt; &lt;option value=&quot;dog&quot;&gt;Dog&lt;/option&gt; &lt;option value=&quot;cat&quot;&gt;Cat&lt;/option&gt; &lt;option value=&quot;hamster&quot;&gt;Hamster&lt;/option&gt; &lt;option value=&quot;parrot&quot;&gt;Parrot&lt;/option&gt; &lt;/select&gt; &lt;select multiple name=&quot;transportation&quot;&gt; &lt;option value=&quot;car&quot;&gt;Car&lt;/option&gt; &lt;option value=&quot;motorcycle&quot;&gt;Motorcycle&lt;/option&gt; &lt;option value=&quot;bus&quot;&gt;Bus&lt;/option&gt; &lt;option value=&quot;jet&quot;&gt;Private Jet&lt;/option&gt; &lt;/select&gt;   ","version":"Next","tagName":"h2"},{"title":"Checkbox​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#checkbox","content":" The checkbox is actually another &quot;type&quot; of input element. These are rendered as boxes that when clicked, become marked as &quot;checked&quot; and are rendered with a check mark. When submitted, the values are either &quot;on&quot; (for checked), or undefined if left unchecked.  &lt;input type=&quot;checkbox&quot; name=&quot;active&quot; /&gt; Active   ","version":"Next","tagName":"h2"},{"title":"Radio Button​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#radio-button","content":" The radio button is similar to &quot;checkbox&quot; in that it is also a &quot;type&quot; of input. However, radio buttons are used when you wish to present a list of options for the user. When grouped together by using the same &quot;name&quot; attribute, they are &quot;mutually-exclusive&quot; (ie: checking one radio button in the group, will automatically deselect the previously checked radio button). When submitted, the value sent is the text in the &quot;value&quot; attribute for the checked radio button.  &lt;input type=&quot;radio&quot; name=&quot;fastFood&quot; value=&quot;hamburger&quot; /&gt; Hamburger &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;fastFood&quot; value=&quot;pizza&quot; /&gt; Pizza &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;fastFood&quot; value=&quot;sandwich&quot; /&gt; Sandwich &lt;br /&gt;   ","version":"Next","tagName":"h2"},{"title":"Label​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#label","content":" The label element is used to provide a label for a form control. You can use the label's 'for' attribute to make the label clickable to focus its associated input (identified by a unique &quot;id&quot;). Alternatively, you can wrap the label text and form control inside a parent &quot;label&quot; element. This adds a nice touch of usability to forms and can make it easier to focus on / interact with areas associated with a label.  &lt;label for=&quot;fullName&quot;&gt;Full Name&lt;/label&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; name=&quot;fullName&quot; id=&quot;fullName&quot; /&gt; &lt;label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;active&quot; /&gt; Active&lt;/label&gt;   ","version":"Next","tagName":"h2"},{"title":"Hidden​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#hidden","content":" The hidden input type is used to include data that cannot be seen or modified by users when a form is submitted. For example, &quot;the ID of the content that is currently being ordered or edited, or a unique security token&quot;.  &lt;input type=&quot;hidden&quot; name=&quot;productID&quot; value=&quot;193774&quot; /&gt;   ","version":"Next","tagName":"h2"},{"title":"Submit​","type":1,"pageTitle":"HTML Form Elements Overview","url":"/WebProgrammingFoundations/Working-With-Forms/html-form-elements-overview#submit","content":" Every form element should contain a &quot;submit&quot; button that will start the process of submitting the form. This typically includes generating an HTTP request using the method identified in the &quot;method&quot; attribute, and sending it to the destination in the &quot;action&quot; attribute. The encoding of the data in the request is controlled by the &quot;enctype&quot; attribute.  A submit button can be created by either using a input element with type=&quot;submit&quot; or a button with type=&quot;submit&quot;.  &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;!-- or --&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;  ","version":"Next","tagName":"h2"},{"title":"Processing URL Encoded Form Data","type":0,"sectionRef":"#","url":"/WebProgrammingFoundations/Working-With-Forms/processing-url-encoded-form-data","content":"","keywords":"","version":"Next"},{"title":"Body Parsing Middleware​","type":1,"pageTitle":"Processing URL Encoded Form Data","url":"/WebProgrammingFoundations/Working-With-Forms/processing-url-encoded-form-data#body-parsing-middleware","content":" As mentioned in the Middleware / Built-In Middleware discussion, we require some &quot;preprocessing&quot; on the &quot;req&quot; object, before we can access the form data in our routes. For example, if we were to submit the form now, the data sent would look something like this:  fullName=John+Smith&amp;blogEntry=Cool+Blog&amp;pet=cat&amp;transportation=car&amp;transportation=bus&amp;fastFood=pizza&amp;active=on&amp;productID=193774   While it does contain the data from the form, it is very difficult to work with and requires manual parsing of the string. Instead, we would prefer an object in memory:  { fullName: &quot;John Smith&quot;, blogEntry: &quot;Cool Blog&quot;, pet: &quot;cat&quot;, transportation: [ &quot;car&quot;, &quot;bus&quot; ], fastFood: &quot;pizza&quot;, active: &quot;on&quot;, productID: &quot;193774&quot; }   This is where &quot;Middleware&quot; comes in, ie: perform some processing on the HTTP Request &quot;body&quot; data, before sending it to our route handlers in the &quot;req&quot; object.  To achieve this, we can use the built-in middleware: express.urlencoded():  app.use(express.urlencoded({ extended: true }));   ","version":"Next","tagName":"h2"},{"title":"Writing The Route Handler​","type":1,"pageTitle":"Processing URL Encoded Form Data","url":"/WebProgrammingFoundations/Working-With-Forms/processing-url-encoded-form-data#writing-the-route-handler","content":" In the example above, the form &quot;action&quot; attribute is set to &quot;/addEntry&quot;. If the form were to be submitted now, Express would return a &quot;404&quot; error with a response containing the text &quot;Cannot POST /addEntry&quot;.  To remedy this, create a &quot;POST&quot; route for &quot;/addEntry&quot;:  app.post('/addEntry', (req, res) =&gt; { res.send(req.body); });   once the &quot;/addEntry&quot; route is in place (beneath our &quot;express.urlencoded()&quot; middleware), we can try submitting the form again. This time, we should see the form data rendered as JSON in the browser.  ","version":"Next","tagName":"h2"},{"title":"Special Consideration (\"checkbox\")​","type":1,"pageTitle":"Processing URL Encoded Form Data","url":"/WebProgrammingFoundations/Working-With-Forms/processing-url-encoded-form-data#special-consideration-checkbox","content":" As previously mentioned in the &quot;checkbox&quot; section of the &quot;HTML Form Elements Review&quot;, checkboxes submit the string &quot;on&quot; when checked and undefined when unchecked. Instead, we would prefer that the value be true or false. As a simple fix for this, we can add the following code:  req.body.active = req.body.active ? true : false;   Here, we see if the &quot;active&quot; value is truthy (ie: not false, 0, -0, 0n, &quot;&quot;, null, undefined, or NaN) and if it is, set it explicitly to &quot;true&quot;. If the value is &quot;falsy&quot; (ie: undefined), then set it explicitly to &quot;false&quot;.  app.post('/addEntry', (req, res) =&gt; { req.body.active = req.body.active ? true : false; res.send(req.body); });  ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}